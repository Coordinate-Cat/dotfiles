'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = require("path");
const extend = require("extend");
const parserService = require("./parser");
const io = require("../utils/io");
const pathManager = require("../managers/path");
function hasExtendsProperty(config, options) {
    return config.hasOwnProperty(options.props.extends);
}
function getExtendsPath(config, options) {
    return config[options.props.extends];
}
function isPackageFile(filepath, config, options) {
    return config && options.props.package && filepath.endsWith('package.json');
}
function getPackageProperty(config, options) {
    return config[options.props.package];
}
function include(cache, filepath, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let isStop = false;
        let currentConfig;
        let currentPath = filepath;
        const stack = [];
        while (!isStop) {
            const exists = yield io.existsPath(currentPath);
            if (!exists) {
                throw new Error('A file that does not exist: ' + currentPath);
            }
            // Try to use cached config
            const stats = yield io.statPath(currentPath);
            if (options.cache && cache.has(currentPath)) {
                const cachedConfig = cache.get(currentPath);
                if (cachedConfig.ctime >= stats.ctime.getTime()) {
                    currentConfig = cachedConfig;
                }
            }
            // Try to read config from File System
            if (!currentConfig) {
                const content = yield io.readFile(currentPath);
                currentConfig = parserService.parse(content, currentPath, stats.ctime.getTime(), options);
                // If it is a "package.json" file then extract config from "packageProp" property
                if (isPackageFile(filepath, currentConfig, options)) {
                    currentConfig.config = getPackageProperty(currentConfig.config, options);
                    if (!currentConfig.config) {
                        return null;
                    }
                }
                if (options.cache) {
                    cache.set(currentPath, currentConfig);
                }
            }
            stack.push(currentConfig.config);
            // Try to find "extends" property
            if (hasExtendsProperty(currentConfig.config, options)) {
                const extendsPath = getExtendsPath(currentConfig.config, options);
                // Try to get config from predefined configs
                const predefinedConfig = options.predefinedConfigs[extendsPath];
                if (predefinedConfig) {
                    stack.push(predefinedConfig);
                    break;
                }
                // Resolve path to config for next iteration
                const currentDir = path.dirname(currentPath);
                currentPath = pathManager.resolve(currentDir, extendsPath);
                currentConfig = null;
                continue;
            }
            isStop = true;
            currentConfig = null;
        }
        // Build config from dirty configs
        let buildedConfig = { extends: null };
        while (stack.length) {
            buildedConfig = extend(true, buildedConfig, stack.pop());
        }
        // Delete "extends" property for builded config
        if (options.props.extends) {
            delete buildedConfig.extends;
        }
        return buildedConfig;
    });
}
exports.include = include;
