'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const locatePath = require("locate-path");
const debuglog = require("debug");
const io = require("../utils/io");
const configManager = require("../managers/config");
const pathManager = require("../managers/path");
const configService = require("../services/config");
const types_1 = require("../types");
const debug = debuglog('config-profiler:services:scanner');
function isString(arg) {
    return typeof arg === 'string';
}
function isObject(arg) {
    return typeof arg === 'object';
}
function isEmptyObject(arg) {
    return Object.keys(arg).length === 0;
}
function isPredefinedConfig(predefinedConfigs, configName) {
    return predefinedConfigs.hasOwnProperty(configName);
}
function hasEnvVariable(options) {
    return Boolean(options.envVariableName) && Boolean(process.env[options.envVariableName]);
}
function getEnvVariable(options) {
    return process.env[options.envVariableName];
}
function linkToHome(filepath) {
    return pathManager.resolve(null, `~/${filepath}`);
}
function scan(cache, cwd, filepath, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // Try to use config from editor settings
        const settings = options.settings;
        if (settings && isObject(settings) && !isEmptyObject(settings)) {
            debug('Returns config from editor settings.');
            return configManager.build(types_1.ConfigType.Settings, null, settings, options);
        }
        // Try to use predefined config
        const predefinedConfigs = options.predefinedConfigs;
        if (settings && isString(settings) && isPredefinedConfig(predefinedConfigs, settings)) {
            debug(`Returns config from predefined configs by name: "${settings}".`);
            return configManager.build(types_1.ConfigType.Predefined, null, predefinedConfigs[settings], options);
        }
        // Try to get config from settings
        if (settings && isString(settings)) {
            const configPath = pathManager.resolve(cwd, settings);
            const config = yield configService.include(cache, configPath, options);
            if (config) {
                debug(`Returns config from settings by path: "${configPath}".`);
                return configManager.build(types_1.ConfigType.File, configPath, config, options);
            }
        }
        // Try to get config from env
        if (hasEnvVariable(options)) {
            const configPath = getEnvVariable(options);
            const config = yield configService.include(cache, configPath, options);
            if (config) {
                debug(`Returns config from "${options.envVariableName}" variable by path: "${configPath}".`);
                return configManager.build(types_1.ConfigType.File, configPath, config, options);
            }
        }
        // Try to find config in the workspace and HOME directories
        let findedConfigPath = yield io.findUp(options.configFiles, filepath, cwd);
        if (!findedConfigPath && options.allowHomeDirectory) {
            findedConfigPath = yield locatePath(options.configFiles.map(linkToHome), {});
        }
        if (findedConfigPath) {
            const config = yield configService.include(cache, findedConfigPath, options);
            if (config) {
                debug(`Returns config by path: "${findedConfigPath}".`);
                return configManager.build(types_1.ConfigType.File, findedConfigPath, config, options);
            }
        }
        debug(`Config is not founded.`);
        return null;
    });
}
exports.scan = scan;
