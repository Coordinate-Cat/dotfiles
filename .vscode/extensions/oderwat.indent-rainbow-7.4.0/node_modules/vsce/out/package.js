"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var cp = require("child_process");
var _ = require("lodash");
var yazl = require("yazl");
var nls_1 = require("./nls");
var util = require("./util");
var _glob = require("glob");
var minimatch = require("minimatch");
var denodeify = require("denodeify");
var markdownit = require("markdown-it");
var cheerio = require("cheerio");
var url = require("url");
var mime = require("mime");
var urljoin = require("url-join");
var validation_1 = require("./validation");
var npm_1 = require("./npm");
var readFile = denodeify(fs.readFile);
var unlink = denodeify(fs.unlink);
var stat = denodeify(fs.stat);
var exec = denodeify(cp.exec, function (err, stdout, stderr) { return [err, { stdout: stdout, stderr: stderr }]; });
var glob = denodeify(_glob);
var resourcesPath = path.join(path.dirname(__dirname), 'resources');
var vsixManifestTemplatePath = path.join(resourcesPath, 'extension.vsixmanifest');
var contentTypesTemplatePath = path.join(resourcesPath, '[Content_Types].xml');
var MinimatchOptions = { dot: true };
function read(file) {
    if (file.contents) {
        return Promise.resolve(file.contents).then(function (b) { return typeof b === 'string' ? b : b.toString('utf8'); });
    }
    else {
        return readFile(file.localPath, 'utf8');
    }
}
exports.read = read;
var BaseProcessor = /** @class */ (function () {
    function BaseProcessor(manifest) {
        this.manifest = manifest;
        this.assets = [];
        this.vsix = Object.create(null);
    }
    BaseProcessor.prototype.onFile = function (file) { return Promise.resolve(file); };
    BaseProcessor.prototype.onEnd = function () { return Promise.resolve(null); };
    return BaseProcessor;
}());
exports.BaseProcessor = BaseProcessor;
function getUrl(url) {
    if (!url) {
        return null;
    }
    if (typeof url === 'string') {
        return url;
    }
    return url.url;
}
function getRepositoryUrl(url) {
    var result = getUrl(url);
    if (/^[^\/]+\/[^\/]+$/.test(result)) {
        return "https://github.com/" + result + ".git";
    }
    return result;
}
// Contributed by Mozilla develpoer authors
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function toExtensionTags(extensions) {
    return extensions
        .map(function (s) { return s.replace(/\W/g, ''); })
        .filter(function (s) { return !!s; })
        .map(function (s) { return "__ext_" + s; });
}
function toLanguagePackTags(translations, languageId) {
    return (translations || [])
        .map(function (_a) {
        var id = _a.id;
        return ["__lp_" + id, "__lp-" + languageId + "_" + id];
    })
        .reduce(function (r, t) { return r.concat(t); }, []);
}
/* This list is also maintained by the Marketplace team.
 * Remember to reach out to them when adding new domains.
 */
var TrustedSVGSources = [
    'api.bintray.com',
    'api.travis-ci.com',
    'api.travis-ci.org',
    'app.fossa.io',
    'badge.fury.io',
    'badge.waffle.io',
    'badgen.net',
    'badges.frapsoft.com',
    'badges.gitter.im',
    'badges.greenkeeper.io',
    'cdn.travis-ci.com',
    'cdn.travis-ci.org',
    'ci.appveyor.com',
    'codacy.com',
    'codeclimate.com',
    'codecov.io',
    'coveralls.io',
    'david-dm.org',
    'deepscan.io',
    'gemnasium.com',
    'githost.io',
    'gitlab.com',
    'godoc.org',
    'goreportcard.com',
    'img.shields.io',
    'isitmaintained.com',
    'marketplace.visualstudio.com',
    'nodesecurity.io',
    'opencollective.com',
    'snyk.io',
    'travis-ci.com',
    'travis-ci.org',
    'vsmarketplacebadge.apphb.com',
    'www.bithound.io',
    'www.versioneye.com'
];
function isHostTrusted(host) {
    return TrustedSVGSources.indexOf(host.toLowerCase()) > -1;
}
var ManifestProcessor = /** @class */ (function (_super) {
    __extends(ManifestProcessor, _super);
    function ManifestProcessor(manifest) {
        var _this = _super.call(this, manifest) || this;
        var flags = ['Public'];
        if (manifest.preview) {
            flags.push('Preview');
        }
        var repository = getRepositoryUrl(manifest.repository);
        var isGitHub = /^https:\/\/github\.com\/|^git@github\.com:/.test(repository || '');
        var enableMarketplaceQnA;
        var customerQnALink;
        if (manifest.qna === 'marketplace') {
            enableMarketplaceQnA = true;
        }
        else if (typeof manifest.qna === 'string') {
            customerQnALink = manifest.qna;
        }
        else if (manifest.qna === false) {
            enableMarketplaceQnA = false;
        }
        _this.vsix = __assign({}, _this.vsix, { id: manifest.name, displayName: manifest.displayName || manifest.name, version: manifest.version, publisher: manifest.publisher, engine: manifest.engines['vscode'], description: manifest.description || '', categories: (manifest.categories || []).join(','), flags: flags.join(' '), links: {
                repository: repository,
                bugs: getUrl(manifest.bugs),
                homepage: manifest.homepage
            }, galleryBanner: manifest.galleryBanner || {}, badges: manifest.badges, githubMarkdown: manifest.markdown !== 'standard', enableMarketplaceQnA: enableMarketplaceQnA,
            customerQnALink: customerQnALink, extensionDependencies: _(manifest.extensionDependencies || []).uniq().join(','), extensionPack: _(manifest.extensionPack || []).uniq().join(','), localizedLanguages: (manifest.contributes && manifest.contributes.localizations) ?
                manifest.contributes.localizations.map(function (loc) { return loc.localizedLanguageName || loc.languageName || loc.languageId; }).join(',') : '' });
        if (isGitHub) {
            _this.vsix.links.github = repository;
        }
        return _this;
    }
    ManifestProcessor.prototype.onEnd = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (this.manifest.publisher === 'vscode-samples') {
                            throw new Error('It\'s not allowed to use the \'vscode-samples\' publisher. Learn more at: https://code.visualstudio.com/api/working-with-extensions/publishing-extension.');
                        }
                        if (!!this.manifest.repository) return [3 /*break*/, 2];
                        util.log.warn("A 'repository' field is missing from the 'package.json' manifest file.");
                        _b = (_a = /^y$/i).test;
                        return [4 /*yield*/, util.read('Do you want to continue? [y/N] ')];
                    case 1:
                        if (!_b.apply(_a, [_c.sent()])) {
                            throw new Error('Aborted');
                        }
                        _c.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    return ManifestProcessor;
}(BaseProcessor));
var TagsProcessor = /** @class */ (function (_super) {
    __extends(TagsProcessor, _super);
    function TagsProcessor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TagsProcessor.prototype.onEnd = function () {
        var keywords = this.manifest.keywords || [];
        var contributes = this.manifest.contributes;
        var activationEvents = this.manifest.activationEvents || [];
        var doesContribute = function (name) { return contributes && contributes[name] && contributes[name].length > 0; };
        var colorThemes = doesContribute('themes') ? ['theme', 'color-theme'] : [];
        var iconThemes = doesContribute('iconThemes') ? ['theme', 'icon-theme'] : [];
        var snippets = doesContribute('snippets') ? ['snippet'] : [];
        var keybindings = doesContribute('keybindings') ? ['keybindings'] : [];
        var debuggers = doesContribute('debuggers') ? ['debuggers'] : [];
        var json = doesContribute('jsonValidation') ? ['json'] : [];
        var localizationContributions = ((contributes && contributes['localizations']) || [])
            .reduce(function (r, l) { return r.concat(["lp-" + l.languageId], toLanguagePackTags(l.translations, l.languageId)); }, []);
        var languageContributions = ((contributes && contributes['languages']) || [])
            .reduce(function (r, l) { return r.concat([l.id], (l.aliases || []), toExtensionTags(l.extensions || [])); }, []);
        var languageActivations = activationEvents
            .map(function (e) { return /^onLanguage:(.*)$/.exec(e); })
            .filter(function (r) { return !!r; })
            .map(function (r) { return r[1]; });
        var grammars = ((contributes && contributes['grammars']) || [])
            .map(function (g) { return g.language; });
        var description = this.manifest.description || '';
        var descriptionKeywords = Object.keys(TagsProcessor.Keywords)
            .reduce(function (r, k) { return r.concat(new RegExp('\\b(?:' + escapeRegExp(k) + ')(?!\\w)', 'gi').test(description) ? TagsProcessor.Keywords[k] : []); }, []);
        var tags = keywords.concat(colorThemes, iconThemes, snippets, keybindings, debuggers, json, localizationContributions, languageContributions, languageActivations, grammars, descriptionKeywords);
        this.vsix.tags = _(tags)
            .uniq() // deduplicate
            .compact() // remove falsey values
            .join(',');
        return Promise.resolve(null);
    };
    TagsProcessor.Keywords = {
        'git': ['git'],
        'npm': ['node'],
        'spell': ['markdown'],
        'bootstrap': ['bootstrap'],
        'lint': ['linters'],
        'linting': ['linters'],
        'react': ['javascript'],
        'js': ['javascript'],
        'node': ['javascript', 'node'],
        'c++': ['c++'],
        'Cplusplus': ['c++'],
        'xml': ['xml'],
        'angular': ['javascript'],
        'jquery': ['javascript'],
        'php': ['php'],
        'python': ['python'],
        'latex': ['latex'],
        'ruby': ['ruby'],
        'java': ['java'],
        'erlang': ['erlang'],
        'sql': ['sql'],
        'nodejs': ['node'],
        'c#': ['c#'],
        'css': ['css'],
        'javascript': ['javascript'],
        'ftp': ['ftp'],
        'haskell': ['haskell'],
        'unity': ['unity'],
        'terminal': ['terminal'],
        'powershell': ['powershell'],
        'laravel': ['laravel'],
        'meteor': ['meteor'],
        'emmet': ['emmet'],
        'eslint': ['linters'],
        'tfs': ['tfs'],
        'rust': ['rust']
    };
    return TagsProcessor;
}(BaseProcessor));
exports.TagsProcessor = TagsProcessor;
var MarkdownProcessor = /** @class */ (function (_super) {
    __extends(MarkdownProcessor, _super);
    function MarkdownProcessor(manifest, name, regexp, assetType, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, manifest) || this;
        _this.name = name;
        _this.regexp = regexp;
        _this.assetType = assetType;
        var guess = _this.guessBaseUrls();
        _this.baseContentUrl = options.baseContentUrl || (guess && guess.content);
        _this.baseImagesUrl = options.baseImagesUrl || options.baseContentUrl || (guess && guess.images);
        return _this;
    }
    MarkdownProcessor.prototype.onFile = function (file) {
        return __awaiter(this, void 0, void 0, function () {
            var path, contents, markdownPathRegex, urlReplace, html, $;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = util.normalize(file.path);
                        if (!this.regexp.test(path)) {
                            return [2 /*return*/, Promise.resolve(file)];
                        }
                        this.assets.push({ type: this.assetType, path: path });
                        return [4 /*yield*/, read(file)];
                    case 1:
                        contents = _a.sent();
                        if (/This is the README for your extension /.test(contents)) {
                            throw new Error("Make sure to edit the README.md file before you publish your extension.");
                        }
                        markdownPathRegex = /(!?)\[([^\]\[]*|!\[[^\]\[]*]\([^\)]+\))\]\(([^\)]+)\)/g;
                        urlReplace = function (all, isImage, title, link) {
                            var isLinkRelative = !/^\w+:\/\//.test(link) && link[0] !== '#';
                            if (!_this.baseContentUrl && !_this.baseImagesUrl) {
                                var asset = isImage ? 'image' : 'link';
                                if (isLinkRelative) {
                                    throw new Error("Couldn't detect the repository where this extension is published. The " + asset + " '" + link + "' will be broken in " + _this.name + ". Please provide the repository URL in package.json or use the --baseContentUrl and --baseImagesUrl options.");
                                }
                            }
                            title = title.replace(markdownPathRegex, urlReplace);
                            var prefix = isImage ? _this.baseImagesUrl : _this.baseContentUrl;
                            if (!prefix || !isLinkRelative) {
                                return isImage + "[" + title + "](" + link + ")";
                            }
                            return isImage + "[" + title + "](" + urljoin(prefix, link) + ")";
                        };
                        contents = contents.replace(markdownPathRegex, urlReplace);
                        html = markdownit({ html: true }).render(contents);
                        $ = cheerio.load(html);
                        $('img').each(function (_, img) {
                            var src = decodeURI(img.attribs.src);
                            var srcUrl = url.parse(src);
                            if (/^data:$/i.test(srcUrl.protocol) && /^image$/i.test(srcUrl.host) && /\/svg/i.test(srcUrl.path)) {
                                throw new Error("SVG data URLs are not allowed in " + _this.name + ": " + src);
                            }
                            if (!/^https:$/i.test(srcUrl.protocol)) {
                                throw new Error("Images in " + _this.name + " must come from an HTTPS source: " + src);
                            }
                            if (/\.svg$/i.test(srcUrl.pathname) && !isHostTrusted(srcUrl.host)) {
                                throw new Error("SVGs are restricted in " + _this.name + "; please use other file image formats, such as PNG: " + src);
                            }
                        });
                        $('svg').each(function (_, svg) {
                            throw new Error("SVG tags are not allowed in " + _this.name + ".");
                        });
                        return [2 /*return*/, {
                                path: file.path,
                                contents: new Buffer(contents)
                            }];
                }
            });
        });
    };
    // GitHub heuristics
    MarkdownProcessor.prototype.guessBaseUrls = function () {
        var repository = null;
        if (typeof this.manifest.repository === 'string') {
            repository = this.manifest.repository;
        }
        else if (this.manifest.repository && typeof this.manifest.repository['url'] === 'string') {
            repository = this.manifest.repository['url'];
        }
        if (!repository) {
            return null;
        }
        var regex = /github\.com\/([^/]+)\/([^/]+)(\/|$)/;
        var match = regex.exec(repository);
        if (!match) {
            return null;
        }
        var account = match[1];
        var repositoryName = match[2].replace(/\.git$/i, '');
        return {
            content: "https://github.com/" + account + "/" + repositoryName + "/blob/master",
            images: "https://github.com/" + account + "/" + repositoryName + "/raw/master"
        };
    };
    return MarkdownProcessor;
}(BaseProcessor));
exports.MarkdownProcessor = MarkdownProcessor;
var ReadmeProcessor = /** @class */ (function (_super) {
    __extends(ReadmeProcessor, _super);
    function ReadmeProcessor(manifest, options) {
        if (options === void 0) { options = {}; }
        return _super.call(this, manifest, 'README.md', /^extension\/readme.md$/i, 'Microsoft.VisualStudio.Services.Content.Details', options) || this;
    }
    return ReadmeProcessor;
}(MarkdownProcessor));
exports.ReadmeProcessor = ReadmeProcessor;
var ChangelogProcessor = /** @class */ (function (_super) {
    __extends(ChangelogProcessor, _super);
    function ChangelogProcessor(manifest, options) {
        if (options === void 0) { options = {}; }
        return _super.call(this, manifest, 'CHANGELOG.md', /^extension\/changelog.md$/i, 'Microsoft.VisualStudio.Services.Content.Changelog', options) || this;
    }
    return ChangelogProcessor;
}(MarkdownProcessor));
exports.ChangelogProcessor = ChangelogProcessor;
var LicenseProcessor = /** @class */ (function (_super) {
    __extends(LicenseProcessor, _super);
    function LicenseProcessor(manifest) {
        var _this = _super.call(this, manifest) || this;
        _this.didFindLicense = false;
        var match = /^SEE LICENSE IN (.*)$/.exec(manifest.license || '');
        if (!match || !match[1]) {
            _this.filter = function (name) { return /^extension\/license(\.(md|txt))?$/i.test(name); };
        }
        else {
            var regexp = new RegExp('^extension/' + match[1] + '$');
            _this.filter = regexp.test.bind(regexp);
        }
        _this.vsix.license = null;
        return _this;
    }
    LicenseProcessor.prototype.onFile = function (file) {
        if (!this.didFindLicense) {
            var normalizedPath = util.normalize(file.path);
            if (this.filter(normalizedPath)) {
                if (!path.extname(normalizedPath)) {
                    file.path += '.txt';
                    normalizedPath += '.txt';
                }
                this.assets.push({ type: 'Microsoft.VisualStudio.Services.Content.License', path: normalizedPath });
                this.vsix.license = normalizedPath;
                this.didFindLicense = true;
            }
        }
        return Promise.resolve(file);
    };
    return LicenseProcessor;
}(BaseProcessor));
var IconProcessor = /** @class */ (function (_super) {
    __extends(IconProcessor, _super);
    function IconProcessor(manifest) {
        var _this = _super.call(this, manifest) || this;
        _this.didFindIcon = false;
        _this.icon = manifest.icon ? "extension/" + manifest.icon : null;
        _this.vsix.icon = null;
        return _this;
    }
    IconProcessor.prototype.onFile = function (file) {
        var normalizedPath = util.normalize(file.path);
        if (normalizedPath === this.icon) {
            this.didFindIcon = true;
            this.assets.push({ type: 'Microsoft.VisualStudio.Services.Icons.Default', path: normalizedPath });
            this.vsix.icon = this.icon;
        }
        return Promise.resolve(file);
    };
    IconProcessor.prototype.onEnd = function () {
        if (this.icon && !this.didFindIcon) {
            return Promise.reject(new Error("The specified icon '" + this.icon + "' wasn't found in the extension."));
        }
        return Promise.resolve(null);
    };
    return IconProcessor;
}(BaseProcessor));
var NLSProcessor = /** @class */ (function (_super) {
    __extends(NLSProcessor, _super);
    function NLSProcessor(manifest) {
        var _this = _super.call(this, manifest) || this;
        _this.translations = Object.create(null);
        if (!manifest.contributes || !manifest.contributes.localizations || manifest.contributes.localizations.length === 0) {
            return _this;
        }
        var localizations = manifest.contributes.localizations;
        var translations = Object.create(null);
        // take last reference in the manifest for any given language
        for (var _i = 0, localizations_1 = localizations; _i < localizations_1.length; _i++) {
            var localization = localizations_1[_i];
            for (var _a = 0, _b = localization.translations; _a < _b.length; _a++) {
                var translation = _b[_a];
                if (translation.id === 'vscode' && !!translation.path) {
                    var translationPath = util.normalize(translation.path.replace(/^\.[\/\\]/, ''));
                    translations[localization.languageId.toUpperCase()] = "extension/" + translationPath;
                }
            }
        }
        // invert the map for later easier retrieval
        for (var _c = 0, _d = Object.keys(translations); _c < _d.length; _c++) {
            var languageId = _d[_c];
            _this.translations[translations[languageId]] = languageId;
        }
        return _this;
    }
    NLSProcessor.prototype.onFile = function (file) {
        var normalizedPath = util.normalize(file.path);
        var language = this.translations[normalizedPath];
        if (language) {
            this.assets.push({ type: "Microsoft.VisualStudio.Code.Translation." + language, path: normalizedPath });
        }
        return Promise.resolve(file);
    };
    return NLSProcessor;
}(BaseProcessor));
exports.NLSProcessor = NLSProcessor;
function validateManifest(manifest) {
    validation_1.validatePublisher(manifest.publisher);
    validation_1.validateExtensionName(manifest.name);
    if (!manifest.version) {
        throw new Error('Manifest missing field: version');
    }
    validation_1.validateVersion(manifest.version);
    if (!manifest.engines) {
        throw new Error('Manifest missing field: engines');
    }
    if (!manifest.engines['vscode']) {
        throw new Error('Manifest missing field: engines.vscode');
    }
    validation_1.validateEngineCompatibility(manifest.engines['vscode']);
    if (/\.svg$/i.test(manifest.icon || '')) {
        throw new Error("SVGs can't be used as icons: " + manifest.icon);
    }
    (manifest.badges || []).forEach(function (badge) {
        var decodedUrl = decodeURI(badge.url);
        var srcUrl = url.parse(decodedUrl);
        if (!/^https:$/i.test(srcUrl.protocol)) {
            throw new Error("Badge URLs must come from an HTTPS source: " + badge.url);
        }
        if (/\.svg$/i.test(srcUrl.pathname) && !isHostTrusted(srcUrl.host)) {
            throw new Error("Badge SVGs are restricted. Please use other file image formats, such as PNG: " + badge.url);
        }
    });
    Object.keys((manifest.dependencies || {})).forEach(function (dep) {
        if (dep === 'vscode') {
            throw new Error("You should not depend on 'vscode' in your 'dependencies'. Did you mean to add it to 'devDependencies'?");
        }
    });
    return manifest;
}
exports.validateManifest = validateManifest;
function readManifest(cwd, nls) {
    if (cwd === void 0) { cwd = process.cwd(); }
    if (nls === void 0) { nls = true; }
    var manifestPath = path.join(cwd, 'package.json');
    var manifestNLSPath = path.join(cwd, 'package.nls.json');
    var manifest = readFile(manifestPath, 'utf8')
        .catch(function () { return Promise.reject("Extension manifest not found: " + manifestPath); })
        .then(function (manifestStr) {
        try {
            return Promise.resolve(JSON.parse(manifestStr));
        }
        catch (e) {
            return Promise.reject("Error parsing 'package.json' manifest file: not a valid JSON file.");
        }
    })
        .then(validateManifest);
    if (!nls) {
        return manifest;
    }
    var manifestNLS = readFile(manifestNLSPath, 'utf8')
        .catch(function (err) { return err.code !== 'ENOENT' ? Promise.reject(err) : Promise.resolve('{}'); })
        .then(function (raw) {
        try {
            return Promise.resolve(JSON.parse(raw));
        }
        catch (e) {
            return Promise.reject("Error parsing JSON manifest translations file: " + manifestNLSPath);
        }
    });
    return Promise.all([manifest, manifestNLS]).then(function (_a) {
        var manifest = _a[0], translations = _a[1];
        return nls_1.patchNLS(manifest, translations);
    });
}
exports.readManifest = readManifest;
function toVsixManifest(assets, vsix, options) {
    if (options === void 0) { options = {}; }
    return readFile(vsixManifestTemplatePath, 'utf8')
        .then(function (vsixManifestTemplateStr) { return _.template(vsixManifestTemplateStr); })
        .then(function (vsixManifestTemplate) { return vsixManifestTemplate(vsix); });
}
exports.toVsixManifest = toVsixManifest;
var defaultExtensions = {
    '.json': 'application/json',
    '.vsixmanifest': 'text/xml'
};
function toContentTypes(files) {
    var extensions = Object.keys(_.keyBy(files, function (f) { return path.extname(f.path).toLowerCase(); }))
        .filter(function (e) { return !!e; })
        .reduce(function (r, e) {
        var _a;
        return (__assign({}, r, (_a = {}, _a[e] = mime.lookup(e), _a)));
    }, {});
    var allExtensions = __assign({}, extensions, defaultExtensions);
    var contentTypes = Object.keys(allExtensions).map(function (extension) { return ({
        extension: extension,
        contentType: allExtensions[extension]
    }); });
    return readFile(contentTypesTemplatePath, 'utf8')
        .then(function (contentTypesTemplateStr) { return _.template(contentTypesTemplateStr); })
        .then(function (contentTypesTemplate) { return contentTypesTemplate({ contentTypes: contentTypes }); });
}
exports.toContentTypes = toContentTypes;
var defaultIgnore = [
    '.vscodeignore',
    'package-lock.json',
    'yarn.lock',
    '.editorconfig',
    '.npmrc',
    '.yarnrc',
    '.gitattributes',
    '*.todo',
    'tslint.yaml',
    '.eslintrc*',
    '.babelrc*',
    '.prettierrc',
    'ISSUE_TEMPLATE.md',
    'CONTRIBUTING.md',
    'PULL_REQUEST_TEMPLATE.md',
    'CODE_OF_CONDUCT.md',
    '.github',
    '.travis.yml',
    'appveyor.yml',
    '**/.git/**',
    '**/*.vsix',
    '**/.DS_Store',
    '**/*.vsixmanifest',
    '**/.vscode-test/**'
];
function collectAllFiles(cwd, useYarn, dependencyEntryPoints) {
    if (useYarn === void 0) { useYarn = false; }
    return npm_1.getDependencies(cwd, useYarn, dependencyEntryPoints).then(function (deps) {
        var promises = deps.map(function (dep) {
            return glob('**', { cwd: dep, nodir: true, dot: true, ignore: 'node_modules/**' })
                .then(function (files) { return files
                .map(function (f) { return path.relative(cwd, path.join(dep, f)); })
                .map(function (f) { return f.replace(/\\/g, '/'); }); });
        });
        return Promise.all(promises).then(util.flatten);
    });
}
function collectFiles(cwd, useYarn, dependencyEntryPoints) {
    if (useYarn === void 0) { useYarn = false; }
    return collectAllFiles(cwd, useYarn, dependencyEntryPoints).then(function (files) {
        files = files.filter(function (f) { return !/\r$/m.test(f); });
        return readFile(path.join(cwd, '.vscodeignore'), 'utf8')
            .catch(function (err) { return err.code !== 'ENOENT' ? Promise.reject(err) : Promise.resolve(''); })
            // Parse raw ignore by splitting output into lines and filtering out empty lines and comments
            .then(function (rawIgnore) { return rawIgnore.split(/[\n\r]/).map(function (s) { return s.trim(); }).filter(function (s) { return !!s; }).filter(function (i) { return !/^\s*#/.test(i); }); })
            // Add '/**' to possible folder names
            .then(function (ignore) { return ignore.concat(ignore.filter(function (i) { return !/(^|\/)[^/]*\*[^/]*$/.test(i); }).map(function (i) { return /\/$/.test(i) ? i + "**" : i + "/**"; })); })
            // Combine with default ignore list
            .then(function (ignore) { return defaultIgnore.concat(ignore, ['!package.json']); })
            // Split into ignore and negate list
            .then(function (ignore) { return _.partition(ignore, function (i) { return !/^\s*!/.test(i); }); })
            .then(function (r) { return ({ ignore: r[0], negate: r[1] }); })
            // Filter out files
            .then(function (_a) {
            var ignore = _a.ignore, negate = _a.negate;
            return files.filter(function (f) { return !ignore.some(function (i) { return minimatch(f, i, MinimatchOptions); }) || negate.some(function (i) { return minimatch(f, i.substr(1), MinimatchOptions); }); });
        });
    });
}
function processFiles(processors, files, options) {
    if (options === void 0) { options = {}; }
    var processedFiles = files.map(function (file) { return util.chain(file, processors, function (file, processor) { return processor.onFile(file); }); });
    return Promise.all(processedFiles).then(function (files) {
        return util.sequence(processors.map(function (p) { return function () { return p.onEnd(); }; })).then(function () {
            var assets = _.flatten(processors.map(function (p) { return p.assets; }));
            var vsix = processors.reduce(function (r, p) { return (__assign({}, r, p.vsix)); }, { assets: assets });
            return Promise.all([toVsixManifest(assets, vsix, options), toContentTypes(files)]).then(function (result) {
                return [
                    { path: 'extension.vsixmanifest', contents: new Buffer(result[0], 'utf8') },
                    { path: '[Content_Types].xml', contents: new Buffer(result[1], 'utf8') }
                ].concat(files);
            });
        });
    });
}
exports.processFiles = processFiles;
function createDefaultProcessors(manifest, options) {
    if (options === void 0) { options = {}; }
    return [
        new ManifestProcessor(manifest),
        new TagsProcessor(manifest),
        new ReadmeProcessor(manifest, options),
        new ChangelogProcessor(manifest, options),
        new LicenseProcessor(manifest),
        new IconProcessor(manifest),
        new NLSProcessor(manifest)
    ];
}
exports.createDefaultProcessors = createDefaultProcessors;
function collect(manifest, options) {
    if (options === void 0) { options = {}; }
    var cwd = options.cwd || process.cwd();
    var useYarn = options.useYarn || false;
    var packagedDependencies = options.dependencyEntryPoints || undefined;
    var processors = createDefaultProcessors(manifest, options);
    return collectFiles(cwd, useYarn, packagedDependencies).then(function (fileNames) {
        var files = fileNames.map(function (f) { return ({ path: "extension/" + f, localPath: path.join(cwd, f) }); });
        return processFiles(processors, files, options);
    });
}
exports.collect = collect;
function writeVsix(files, packagePath) {
    return unlink(packagePath)
        .catch(function (err) { return err.code !== 'ENOENT' ? Promise.reject(err) : Promise.resolve(null); })
        .then(function () { return new Promise(function (c, e) {
        var zip = new yazl.ZipFile();
        files.forEach(function (f) { return f.contents ? zip.addBuffer(typeof f.contents === 'string' ? new Buffer(f.contents, 'utf8') : f.contents, f.path) : zip.addFile(f.localPath, f.path); });
        zip.end();
        var zipStream = fs.createWriteStream(packagePath);
        zip.outputStream.pipe(zipStream);
        zip.outputStream.once('error', e);
        zipStream.once('error', e);
        zipStream.once('finish', function () { return c(packagePath); });
    }); });
}
function defaultPackagePath(cwd, manifest) {
    return path.join(cwd, manifest.name + "-" + manifest.version + ".vsix");
}
function prepublish(cwd, manifest) {
    if (!manifest.scripts || !manifest.scripts['vscode:prepublish']) {
        return Promise.resolve(manifest);
    }
    console.warn("Executing prepublish script 'npm run vscode:prepublish'...");
    return exec('npm run vscode:prepublish', { cwd: cwd, maxBuffer: 5000 * 1024 })
        .then(function (_a) {
        var stdout = _a.stdout, stderr = _a.stderr;
        process.stdout.write(stdout);
        process.stderr.write(stderr);
        return Promise.resolve(manifest);
    })
        .catch(function (err) { return Promise.reject(err.message); });
}
function pack(options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var cwd, manifest, files, packagePath;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    cwd = options.cwd || process.cwd();
                    return [4 /*yield*/, readManifest(cwd)];
                case 1:
                    manifest = _a.sent();
                    return [4 /*yield*/, prepublish(cwd, manifest)];
                case 2:
                    manifest = _a.sent();
                    return [4 /*yield*/, collect(manifest, options)];
                case 3:
                    files = _a.sent();
                    return [4 /*yield*/, writeVsix(files, path.resolve(options.packagePath || defaultPackagePath(cwd, manifest)))];
                case 4:
                    packagePath = _a.sent();
                    return [2 /*return*/, { manifest: manifest, packagePath: packagePath, files: files }];
            }
        });
    });
}
exports.pack = pack;
function packageCommand(options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var _a, packagePath, files, stats, size, unit;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, pack(options)];
                case 1:
                    _a = _b.sent(), packagePath = _a.packagePath, files = _a.files;
                    return [4 /*yield*/, stat(packagePath)];
                case 2:
                    stats = _b.sent();
                    size = 0;
                    unit = '';
                    if (stats.size > 1048576) {
                        size = Math.round(stats.size / 10485.76) / 100;
                        unit = 'MB';
                    }
                    else {
                        size = Math.round(stats.size / 10.24) / 100;
                        unit = 'KB';
                    }
                    util.log.done("Packaged: " + packagePath + " (" + files.length + " files, " + size + unit + ")");
                    return [2 /*return*/];
            }
        });
    });
}
exports.packageCommand = packageCommand;
/**
 * Lists the files included in the extension's package. Does not run prepublish.
 */
function listFiles(cwd, useYarn, packagedDependencies) {
    if (cwd === void 0) { cwd = process.cwd(); }
    if (useYarn === void 0) { useYarn = false; }
    return readManifest(cwd)
        .then(function (manifest) { return collectFiles(cwd, useYarn, packagedDependencies); });
}
exports.listFiles = listFiles;
/**
 * Lists the files included in the extension's package. Runs prepublish.
 */
function ls(cwd, useYarn, packagedDependencies) {
    if (cwd === void 0) { cwd = process.cwd(); }
    if (useYarn === void 0) { useYarn = false; }
    return readManifest(cwd)
        .then(function (manifest) { return prepublish(cwd, manifest); })
        .then(function (manifest) { return collectFiles(cwd, useYarn, packagedDependencies); })
        .then(function (files) { return files.forEach(function (f) { return console.log("" + f); }); });
}
exports.ls = ls;

//# sourceMappingURL=package.js.map
