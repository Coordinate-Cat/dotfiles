"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var GalleryInterfaces_1 = require("vso-node-api/interfaces/GalleryInterfaces");
var package_1 = require("./package");
var tmp = require("tmp");
var store_1 = require("./store");
var util_1 = require("./util");
var validation_1 = require("./validation");
var denodeify = require("denodeify");
var yauzl = require("yauzl");
var semver = require("semver");
var cp = require("child_process");
var exec = denodeify(cp.exec, function (err, stdout, stderr) { return [err, { stdout: stdout, stderr: stderr }]; });
var tmpName = denodeify(tmp.tmpName);
function readManifestFromPackage(packagePath) {
    return new Promise(function (c, e) {
        yauzl.open(packagePath, function (err, zipfile) {
            if (err) {
                return e(err);
            }
            var onEnd = function () { return e(new Error('Manifest not found')); };
            zipfile.once('end', onEnd);
            zipfile.on('entry', function (entry) {
                if (!/^extension\/package\.json$/i.test(entry.fileName)) {
                    return;
                }
                zipfile.removeListener('end', onEnd);
                zipfile.openReadStream(entry, function (err, stream) {
                    if (err) {
                        return e(err);
                    }
                    var buffers = [];
                    stream.on('data', function (buffer) { return buffers.push(buffer); });
                    stream.once('error', e);
                    stream.once('end', function () {
                        try {
                            c(JSON.parse(Buffer.concat(buffers).toString('utf8')));
                        }
                        catch (err) {
                            e(err);
                        }
                    });
                });
            });
        });
    });
}
function _publish(packagePath, pat, manifest) {
    var api = util_1.getGalleryAPI(pat);
    var packageStream = fs.createReadStream(packagePath);
    var name = manifest.publisher + "." + manifest.name;
    var fullName = name + "@" + manifest.version;
    console.log("Publishing " + fullName + "...");
    return api.getExtension(manifest.publisher, manifest.name, null, GalleryInterfaces_1.ExtensionQueryFlags.IncludeVersions)
        .catch(function (err) { return err.statusCode === 404 ? null : Promise.reject(err); })
        .then(function (extension) {
        if (extension && extension.versions.some(function (v) { return v.version === manifest.version; })) {
            return Promise.reject(fullName + " already exists. Version number cannot be the same.");
        }
        var promise = extension
            ? api.updateExtension(undefined, packageStream, manifest.publisher, manifest.name)
            : api.createExtension(undefined, packageStream);
        return promise
            .catch(function (err) { return Promise.reject(err.statusCode === 409 ? fullName + " already exists." : err); })
            .then(function () { return util_1.log.done("Published " + fullName + "\nYour extension will live at " + util_1.getPublishedUrl(name) + " (might take a few seconds for it to show up)."); });
    })
        .catch(function (err) {
        var message = err && err.message || '';
        if (/Invalid Resource/.test(message)) {
            err.message = err.message + "\n\nYou're likely using an expired Personal Access Token, please get a new PAT.\nMore info: https://aka.ms/vscodepat";
        }
        return Promise.reject(err);
    });
}
function versionBump(cwd, version) {
    if (cwd === void 0) { cwd = process.cwd(); }
    if (!version) {
        return Promise.resolve(null);
    }
    switch (version) {
        case 'major':
        case 'minor':
        case 'patch':
            break;
        case 'premajor':
        case 'preminor':
        case 'prepatch':
        case 'prerelease':
        case 'from-git':
            return Promise.reject("Not supported: " + version);
        default:
            if (!semver.valid(version)) {
                return Promise.reject("Invalid version " + version);
            }
    }
    // call `npm version` to do our dirty work
    return exec("npm version " + version, { cwd: cwd })
        .then(function (_a) {
        var stdout = _a.stdout, stderr = _a.stderr;
        process.stdout.write(stdout);
        process.stderr.write(stderr);
        return Promise.resolve(null);
    })
        .catch(function (err) { return Promise.reject(err.message); });
}
function publish(options) {
    if (options === void 0) { options = {}; }
    var promise;
    if (options.packagePath) {
        if (options.version) {
            return Promise.reject("Not supported: packagePath and version.");
        }
        promise = readManifestFromPackage(options.packagePath)
            .then(function (manifest) { return ({ manifest: manifest, packagePath: options.packagePath }); });
    }
    else {
        var cwd_1 = options.cwd;
        var baseContentUrl_1 = options.baseContentUrl;
        var baseImagesUrl_1 = options.baseImagesUrl;
        var useYarn_1 = options.useYarn;
        promise = versionBump(options.cwd, options.version)
            .then(function () { return tmpName(); })
            .then(function (packagePath) { return package_1.pack({ packagePath: packagePath, cwd: cwd_1, baseContentUrl: baseContentUrl_1, baseImagesUrl: baseImagesUrl_1, useYarn: useYarn_1 }); });
    }
    return promise.then(function (_a) {
        var manifest = _a.manifest, packagePath = _a.packagePath;
        if (manifest.enableProposedApi) {
            throw new Error('Extensions using proposed API (enableProposedApi: true) can\'t be published to the Marketplace');
        }
        var patPromise = options.pat
            ? Promise.resolve(options.pat)
            : store_1.getPublisher(manifest.publisher).then(function (p) { return p.pat; });
        return patPromise.then(function (pat) { return _publish(packagePath, pat, manifest); });
    });
}
exports.publish = publish;
function list(publisher) {
    validation_1.validatePublisher(publisher);
    return store_1.getPublisher(publisher)
        .then(function (p) { return p.pat; })
        .then(util_1.getGalleryAPI)
        .then(function (api) {
        var criteria = [{ filterType: GalleryInterfaces_1.ExtensionQueryFilterType.InstallationTarget, value: 'Microsoft.VisualStudio.Code' }];
        var filters = [{ criteria: criteria, direction: GalleryInterfaces_1.PagingDirection.Forward, pageNumber: 0, pageSize: 1000, pagingToken: null, sortBy: GalleryInterfaces_1.SortByType.Relevance, sortOrder: GalleryInterfaces_1.SortOrderType.Default }];
        var query = { filters: filters, flags: GalleryInterfaces_1.ExtensionQueryFlags.IncludeLatestVersionOnly | GalleryInterfaces_1.ExtensionQueryFlags.IncludeVersionProperties, assetTypes: [] };
        return api.queryExtensions(query).then(function (result) {
            return result.results[0].extensions
                .filter(function (e) { return e.publisher.publisherName === publisher; })
                .forEach(function (e) { return console.log(e.extensionName + " @ " + e.versions[0].version); });
        });
    });
}
exports.list = list;
function unpublish(options) {
    if (options === void 0) { options = {}; }
    var promise;
    if (options.id) {
        var _a = options.id.split('.'), publisher = _a[0], name_1 = _a[1];
        promise = Promise.resolve(({ publisher: publisher, name: name_1 }));
    }
    else {
        promise = package_1.readManifest(options.cwd);
    }
    return promise.then(function (_a) {
        var publisher = _a.publisher, name = _a.name;
        var fullName = publisher + "." + name;
        var pat = options.pat
            ? Promise.resolve(options.pat)
            : store_1.getPublisher(publisher).then(function (p) { return p.pat; });
        return util_1.read("This will FOREVER delete '" + fullName + "'! Are you sure? [y/N] ")
            .then(function (answer) { return /^y$/i.test(answer) ? null : Promise.reject('Aborted'); })
            .then(function () { return pat; })
            .then(util_1.getGalleryAPI)
            .then(function (api) { return api.deleteExtension(publisher, name); })
            .then(function () { return util_1.log.done("Deleted extension: " + fullName + "!"); });
    });
}
exports.unpublish = unpublish;

//# sourceMappingURL=publish.js.map
