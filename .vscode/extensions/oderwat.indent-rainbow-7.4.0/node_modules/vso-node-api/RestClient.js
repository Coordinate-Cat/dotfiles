// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const fs = require("fs");
const httpm = require("./HttpClient");
class RestClient {
    constructor(userAgent, handlers, socketTimeout, versionParam) {
        // TODO: should we really do this?
        this.versionParam = versionParam || 'api-version';
        this.client = new httpm.HttpClient(userAgent, handlers, socketTimeout);
    }
    get(requestUrl, apiVersion, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            var headers = additionalHeaders || {};
            headers["Accept"] = this.createAcceptHeader('application/json', apiVersion);
            let res = yield this.client.get(requestUrl, headers);
            return this._processResponse(res);
        });
    }
    del(requestUrl, apiVersion, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            var headers = additionalHeaders || {};
            headers["Accept"] = this.createAcceptHeader('application/json', apiVersion);
            let res = yield this.client.del(requestUrl, headers);
            return this._processResponse(res);
        });
    }
    create(requestUrl, apiVersion, resources, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            var headers = additionalHeaders || {};
            headers["Accept"] = this.createAcceptHeader('application/json', apiVersion);
            headers["Content-Type"] = headers["Content-Type"] || 'application/json; charset=utf-8';
            let data = JSON.stringify(resources, null, 2);
            let res = yield this.client.post(requestUrl, data, headers);
            return this._processResponse(res);
        });
    }
    update(requestUrl, apiVersion, resources, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            var headers = additionalHeaders || {};
            headers["Accept"] = this.createAcceptHeader('application/json', apiVersion);
            headers["Content-Type"] = headers["Content-Type"] || 'application/json; charset=utf-8';
            let data = JSON.stringify(resources, null, 2);
            let res = yield this.client.patch(requestUrl, data, headers);
            return this._processResponse(res);
        });
    }
    replace(requestUrl, apiVersion, resources, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            var headers = additionalHeaders || {};
            headers["Accept"] = this.createAcceptHeader('application/json', apiVersion);
            headers["Content-Type"] = headers["Content-Type"] || 'application/json; charset=utf-8';
            let data = JSON.stringify(resources, null, 2);
            let res = yield this.client.put(requestUrl, data, headers);
            return this._processResponse(res);
        });
    }
    uploadStream(verb, requestUrl, apiVersion, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            var headers = additionalHeaders || {};
            headers["Accept"] = this.createAcceptHeader('application/json', apiVersion);
            let res = yield this.client.sendStream(verb, requestUrl, stream, headers);
            return this._processResponse(res);
        });
    }
    createAcceptHeader(type, apiVersion) {
        return type + (apiVersion ? (';' + this.versionParam + '=' + apiVersion) : '');
    }
    _processResponse(res) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let rres = {};
                let statusCode = res.message.statusCode;
                rres.statusCode = statusCode;
                // not found leads to null obj returned
                if (statusCode == httpm.HttpCodes.NotFound) {
                    resolve(rres);
                }
                let obj;
                // get the result from the body
                try {
                    let contents = yield res.readBody();
                    if (contents && contents.length > 0) {
                        obj = JSON.parse(contents);
                        rres.result = obj;
                    }
                }
                catch (err) {
                    reject(new Error('Invalid Resource'));
                }
                if (statusCode > 299) {
                    let msg;
                    // if exception/error in body, attempt to get better error
                    if (obj && obj.message) {
                        msg = obj.message;
                    }
                    else {
                        msg = "Failed request: (" + statusCode + ") " + res.message.url;
                    }
                    reject(new Error(msg));
                }
                else {
                    resolve(rres);
                }
            }));
        });
    }
}
exports.RestClient = RestClient;
class RestCallbackClient {
    constructor(httpClient, versionParam) {
        versionParam = versionParam || 'api-version';
        this.httpClient = httpClient;
        this.versionParam = versionParam;
    }
    get(url, apiVersion, customHeaders, onResult) {
        this._getJson('GET', url, apiVersion, customHeaders, onResult);
    }
    del(url, apiVersion, customHeaders, onResult) {
        this._getJson('DELETE', url, apiVersion, customHeaders, onResult);
    }
    create(url, apiVersion, resources, customHeaders, onResult, serializationData) {
        var headers = customHeaders || {};
        headers["Accept"] = this.createAcceptHeader('application/json', apiVersion);
        headers["Content-Type"] = headers["Content-Type"] || 'application/json; charset=utf-8';
        this._sendJson('POST', url, apiVersion, resources, customHeaders, onResult);
    }
    update(url, apiVersion, resources, customHeaders, onResult, serializationData) {
        this._sendJson('PATCH', url, apiVersion, resources, customHeaders, onResult);
    }
    options(url, onResult) {
        this._getJson('OPTIONS', url, "", null, onResult);
    }
    uploadFile(verb, url, apiVersion, filePath, customHeaders, onResult, serializationData) {
        fs.stat(filePath, (err, stats) => {
            if (err) {
                onResult(err, 400, null);
                return;
            }
            var headers = customHeaders || {};
            headers["Content-Length"] = stats.size;
            var contentStream = fs.createReadStream(filePath);
            this.uploadStream(verb, url, apiVersion, contentStream, headers, onResult, serializationData);
        });
    }
    uploadStream(verb, url, apiVersion, contentStream, customHeaders, onResult, serializationData) {
        var headers = customHeaders || {};
        headers["Accept"] = this.createAcceptHeader('application/json', apiVersion);
        this.httpClient.sendStream(verb, url, contentStream, headers, (err, res, contents) => {
            if (err) {
                onResult(err, err.statusCode, contents);
                return;
            }
            _processResponse(url, res, contents, onResult);
        });
    }
    replace(url, apiVersion, resources, customHeaders, onResult) {
        this._sendJson('PUT', url, apiVersion, resources, customHeaders, onResult);
    }
    _getJson(verb, url, apiVersion, customHeaders, onResult) {
        var headers = {};
        headers["Accept"] = this.createAcceptHeader('application/json', apiVersion);
        this.httpClient.get(verb, url, headers, (err, res, contents) => {
            if (err) {
                onResult(err, err.statusCode, null);
                return;
            }
            _processResponse(url, res, contents, onResult);
        });
    }
    _sendJson(verb, url, apiVersion, resources, customHeaders, onResult) {
        if (!resources) {
            throw new Error('invalid resource');
        }
        var headers = customHeaders || {};
        headers["Accept"] = this.createAcceptHeader('application/json', apiVersion);
        headers["Content-Type"] = headers["Content-Type"] || 'application/json; charset=utf-8';
        let data;
        data = JSON.stringify(resources, null, 2);
        this.httpClient.send(verb, url, data, headers, (err, res, contents) => {
            if (err) {
                onResult(err, err.statusCode, null);
                return;
            }
            _processResponse(url, res, contents, onResult);
        });
    }
    createAcceptHeader(type, apiVersion) {
        return type + (apiVersion ? (';' + this.versionParam + '=' + apiVersion) : '');
    }
}
exports.RestCallbackClient = RestCallbackClient;
var httpCodes = {
    300: "Multiple Choices",
    301: "Moved Permanantly",
    302: "Resource Moved",
    304: "Not Modified",
    305: "Use Proxy",
    306: "Switch Proxy",
    307: "Temporary Redirect",
    308: "Permanent Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout"
};
function _processResponse(url, res, contents, onResult) {
    let jsonObj;
    if (contents && contents.length > 0) {
        try {
            jsonObj = JSON.parse(contents);
        }
        catch (e) {
            onResult(new Error('Invalid Resource'), res.statusCode, null);
            return;
        }
    }
    if (res.statusCode > 299) {
        // default error message
        var msg = httpCodes[res.statusCode] ? "Failed Request: " + httpCodes[res.statusCode] : "Failed Request";
        msg += '(' + res.statusCode + ') - ';
        // if exception/error in body, attempt to get better error
        if (jsonObj && jsonObj.message) {
            msg += jsonObj.message;
        }
        else {
            msg += url;
        }
        onResult(new Error(msg), res.statusCode, null);
    }
    else {
        onResult(null, res.statusCode, jsonObj);
    }
}
;
