/*
* ---------------------------------------------------------
* Copyright(C) Microsoft Corporation. All rights reserved.
* ---------------------------------------------------------
*
* ---------------------------------------------------------
* Generated file, DO NOT EDIT
* ---------------------------------------------------------
*/
"use strict";
// Licensed under the MIT license.  See LICENSE file in the project root for full license information.
const stream = require("stream");
const FileContainerApiBase = require("./FileContainerApiBase");
const FileContainerInterfaces = require("./interfaces/FileContainerInterfaces");
class FileContainerApi extends FileContainerApiBase.FileContainerApiBase {
    constructor(baseUrl, handlers) {
        super(baseUrl, handlers);
    }
    createItem(contentStream, uncompressedLength, containerId, itemPath, scope, options) {
        return new Promise((resolve, reject) => {
            let chunkStream = new ChunkStream(this, uncompressedLength, containerId, itemPath, scope, options);
            chunkStream.on('finish', () => {
                resolve(chunkStream.getItem());
            });
            contentStream.pipe(chunkStream);
        });
    }
    _createItem(customHeaders, contentStream, containerId, itemPath, scope, onResult) {
        var routeValues = {
            containerId: containerId
        };
        var queryValues = {
            itemPath: itemPath,
            scope: scope,
        };
        customHeaders = customHeaders || {};
        customHeaders["Content-Type"] = "application/octet-stream";
        this.vsoClient.getVersioningData("2.2-preview.3", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues)
            .then((versioningData) => {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: FileContainerInterfaces.TypeInfo.FileContainerItem, responseIsCollection: false };
            this.restCallbackClient.uploadStream('PUT', url, apiVersion, contentStream, customHeaders, onResult, serializationData);
        }, (error) => {
            onResult(error, error.statusCode, null);
        });
    }
}
exports.FileContainerApi = FileContainerApi;
class ChunkStream extends stream.Writable {
    constructor(api, uncompressedLength, containerId, itemPath, scope, options) {
        super();
        this._buffer = new Buffer(ChunkStream.ChunkSize);
        this._length = 0;
        this._startRange = 0;
        this._bytesToSend = 0;
        this._totalReceived = 0;
        this._api = api;
        this._options = options || {};
        this._uncompressedLength = uncompressedLength;
        this._containerId = containerId;
        this._itemPath = itemPath;
        this._scope = scope;
        this._bytesToSend = this._options.isGzipped ? this._options.compressedLength : uncompressedLength;
    }
    _write(data, encoding, callback) {
        let chunk = data;
        if (!chunk) {
            if (this._length == 0) {
                callback();
            }
            else {
                // last chunk
                this._sendChunk(callback);
            }
            return;
        }
        let newBuffer = null;
        if (this._length + chunk.length > ChunkStream.ChunkSize) {
            // overflow
            let overflowPosition = chunk.length - (ChunkStream.ChunkSize - this._length);
            chunk.copy(this._buffer, this._length, 0, overflowPosition);
            this._length += overflowPosition;
            newBuffer = chunk.slice(overflowPosition);
        }
        else {
            chunk.copy(this._buffer, this._length, 0, chunk.length);
            this._length += chunk.length;
        }
        this._totalReceived += chunk.length;
        if (this._length >= ChunkStream.ChunkSize || this._totalReceived >= this._bytesToSend) {
            this._sendChunk(callback, newBuffer);
        }
        else {
            callback();
        }
    }
    _sendChunk(callback, newBuffer) {
        let endRange = this._startRange + this._length;
        let headers = {
            "Content-Range": "bytes " + this._startRange + "-" + (endRange - 1) + "/" + this._bytesToSend,
            "Content-Length": this._length
        };
        if (this._options.isGzipped) {
            headers["Accept-Encoding"] = "gzip";
            headers["Content-Encoding"] = "gzip";
            headers["x-tfs-filelength"] = this._uncompressedLength;
        }
        this._startRange = endRange;
        this._api._createItem(headers, new BufferStream(this._buffer, this._length), this._containerId, this._itemPath, this._scope, (err, statusCode, item) => {
            if (newBuffer) {
                this._length = newBuffer.length;
                newBuffer.copy(this._buffer);
            }
            else {
                this._length = 0;
            }
            this._item = item;
            callback(err);
        });
    }
    getItem() {
        return this._item;
    }
}
ChunkStream.ChunkSize = (16 * 1024 * 1024);
class BufferStream extends stream.Readable {
    constructor(buffer, length) {
        super();
        this._position = 0;
        this._length = 0;
        this._buffer = buffer;
        this._length = length;
    }
    _read(size) {
        if (this._position >= this._length) {
            this.push(null);
            return;
        }
        let end = Math.min(this._position + size, this._length);
        this.push(this._buffer.slice(this._position, end));
        this._position = end;
    }
}
