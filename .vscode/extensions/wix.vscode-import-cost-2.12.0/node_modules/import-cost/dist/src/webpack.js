'use strict';

var webpack = require('webpack');
var MemoryFS = require('memory-fs');
var BabiliPlugin = require('babili-webpack-plugin');
var pkgDir = require('pkg-dir');
var tempy = require('tempy');
var fs = require('fs');
var path = require('path');

var _require = require('zlib'),
    gzipSync = _require.gzipSync;

var _require2 = require('./utils'),
    getPackageJson = _require2.getPackageJson,
    getPackageModuleContainer = _require2.getPackageModuleContainer;

function getEntryPoint(packageInfo) {
  var tmpFile = tempy.file({ extension: 'js' });
  fs.writeFileSync(tmpFile, packageInfo.string, 'utf-8');
  return tmpFile;
}

function calcSize(packageInfo, callback) {
  var entryPoint = getEntryPoint(packageInfo);
  var packageRootDir = pkgDir.sync(path.dirname(packageInfo.fileName));
  var modulesDirectory = path.join(packageRootDir, 'node_modules');
  var peers = getPackageJson(packageInfo).peerDependencies || {};
  var defaultExternals = ['react', 'react-dom', 'lodash'];
  var externals = Object.keys(peers).concat(defaultExternals).filter(function (p) {
    return p !== packageInfo.name;
  });

  var compiler = webpack({
    entry: entryPoint,
    plugins: [new webpack.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify('production')
    }), new webpack.optimize.ModuleConcatenationPlugin(), new webpack.IgnorePlugin(/^electron$/), new BabiliPlugin()],
    resolve: {
      modules: [modulesDirectory, getPackageModuleContainer(packageInfo), 'node_modules']
    },
    module: {
      rules: [{
        test: /\.s?css$/,
        use: 'css-loader'
      }, {
        test: /\.(png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot|wav)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          name: '[path][name].[ext]?[hash]',
          limit: 10000
        }
      }]
    },
    node: {
      fs: 'empty',
      net: 'empty',
      tls: 'empty',
      module: 'empty',
      child_process: 'empty', //eslint-disable-line
      dns: 'empty'
    },
    externals: externals,
    output: {
      filename: 'bundle.js'
    }
  });

  var memoryFileSystem = new MemoryFS();
  compiler.outputFileSystem = memoryFileSystem;

  compiler.run(function (err, stats) {
    if (err || stats.toJson().errors.length > 0) {
      callback({ err: err || stats.toJson().errors });
    } else {
      var bundles = stats.toJson().assets.filter(function (asset) {
        return asset.name.includes('bundle.js');
      });
      var size = bundles.reduce(function (sum, pkg) {
        return sum + pkg.size;
      }, 0);
      var gzip = bundles.map(function (bundle) {
        return path.join(process.cwd(), 'dist', bundle.name);
      }).map(function (bundleFile) {
        return gzipSync(memoryFileSystem.readFileSync(bundleFile), {}).length;
      }).reduce(function (sum, gzipSize) {
        return sum + gzipSize;
      }, 0);
      callback(null, { size: size, gzip: gzip });
    }
  });
}

module.exports = { calcSize: calcSize };