'use strict';

exports.__esModule = true;
exports.getPackages = getPackages;

var _traverse = require('@babel/traverse');

var _traverse2 = _interopRequireDefault(_traverse);

var _types = require('@babel/types');

var t = _interopRequireWildcard(_types);

var _parser = require('@babel/parser');

var _parser2 = require('./parser');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PARSE_PLUGINS = ['jsx', 'asyncFunctions', 'classConstructorCall', 'doExpressions', 'trailingFunctionCommas', 'objectRestSpread', ['decorators', { decoratorsBeforeExport: true }], 'classProperties', 'exportExtensions', 'exponentiationOperator', 'asyncGenerators', 'functionBind', 'functionSent', 'dynamicImport'];
var PARSE_JS_PLUGINS = ['flow'].concat(PARSE_PLUGINS);
var PARSE_TS_PLUGINS = ['typescript'].concat(PARSE_PLUGINS);

function getPackages(fileName, source, language) {
  var packages = [];
  var visitor = {
    ImportDeclaration: function ImportDeclaration(_ref) {
      var node = _ref.node;

      packages.push({
        fileName: fileName,
        name: node.source.value,
        line: node.loc.end.line,
        string: compileImportString(node)
      });
    },
    CallExpression: function CallExpression(_ref2) {
      var node = _ref2.node;

      if (node.callee.name === 'require') {
        packages.push({
          fileName: fileName,
          name: getPackageName(node),
          line: node.loc.end.line,
          string: compileRequireString(node)
        });
      } else if (node.callee.type === 'Import') {
        packages.push({
          fileName: fileName,
          name: getPackageName(node),
          line: node.loc.end.line,
          string: compileImportExpressionString(node)
        });
      }
    }
  };

  var ast = parse(source, language);
  (0, _traverse2.default)(ast, visitor);
  return packages;
}

function parse(source, language) {
  var plugins = language === _parser2.TYPESCRIPT ? PARSE_TS_PLUGINS : PARSE_JS_PLUGINS;
  return (0, _parser.parse)(source, {
    sourceType: 'module',
    plugins: plugins
  });
}

function compileImportString(node) {
  var importSpecifiers = void 0,
      importString = void 0;
  if (node.specifiers && node.specifiers.length > 0) {
    importString = [].concat(node.specifiers).sort(function (s1, s2) {
      // Import specifiers are in statement order, which for mixed imports must be either "defaultImport, * as namespaceImport"
      // or "defaultImport, { namedImport [as alias]... } according to current ECMA-262.
      // Given that two equivalent import statements can only differ in the order of the items in a NamedImports block,
      // we only need to sort these items in relation to each other to normalise the statements for caching purposes.
      // Where the node is anything other than ImportSpecifier (Babel terminoligy for NamedImports), preserve the original statement order.
      if (t.isImportSpecifier(s1) && t.isImportSpecifier(s2)) {
        return s1.imported.name < s2.imported.name ? -1 : 1;
      }
      return 0;
    }).map(function (specifier, i) {
      if (t.isImportNamespaceSpecifier(specifier)) {
        return '* as ' + specifier.local.name;
      } else if (t.isImportDefaultSpecifier(specifier)) {
        return specifier.local.name;
      } else if (t.isImportSpecifier(specifier)) {
        if (!importSpecifiers) {
          importSpecifiers = '{';
        }
        importSpecifiers += specifier.imported.name;
        if (node.specifiers[i + 1] && t.isImportSpecifier(node.specifiers[i + 1])) {
          importSpecifiers += ', ';
          return undefined;
        } else {
          var result = importSpecifiers + '}';
          importSpecifiers = undefined;
          return result;
        }
      } else {
        return undefined;
      }
    }).filter(function (x) {
      return x;
    }).join(', ');
  } else {
    importString = '* as tmp';
  }
  return 'import ' + importString + ' from \'' + node.source.value + '\';\nconsole.log(' + importString.replace('* as ', '') + ');';
}

function compileRequireString(node) {
  return 'require(\'' + getPackageName(node) + '\')';
}

function compileImportExpressionString(node) {
  return 'import(\'' + getPackageName(node) + '\').then(res => console.log(res));';
}

function getPackageName(node) {
  return t.isTemplateLiteral(node.arguments[0]) ? node.arguments[0].quasis[0].value.raw : node.arguments[0].value;
}