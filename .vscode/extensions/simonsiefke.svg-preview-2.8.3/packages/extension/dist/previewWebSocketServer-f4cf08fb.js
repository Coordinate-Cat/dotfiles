function _interopDefault(ex){return ex&&"object"==typeof ex&&"default"in ex?ex.default:ex}var _commonjsHelpers=require("./_commonjsHelpers-359a085d.js"),http__default=_interopDefault(require("http")),https__default=_interopDefault(require("https")),net=_interopDefault(require("net")),events=_interopDefault(require("events")),tls=_interopDefault(require("tls")),crypto=_interopDefault(require("crypto")),url=_interopDefault(require("url")),zlib=_interopDefault(require("zlib")),stream$1=_interopDefault(require("stream"));class Locked extends Error{constructor(port){super(`${port} is locked`)}}const lockedPorts={old:new Set,young:new Set};let interval;const getAvailablePort=options=>new Promise((resolve,reject)=>{const server=net.createServer();server.unref(),server.on("error",reject),server.listen(options,()=>{const{port}=server.address();server.close(()=>{resolve(port)})})});var getPort=async options=>{let ports;options&&(ports="number"==typeof options.port?[options.port]:options.port),void 0===interval&&(interval=setInterval(()=>{lockedPorts.old=lockedPorts.young,lockedPorts.young=new Set},15e3),interval.unref&&interval.unref());for(const port of function*(ports){ports&&(yield*ports),yield 0}(ports))try{let availablePort=await getAvailablePort({...options,port});for(;lockedPorts.old.has(availablePort)||lockedPorts.young.has(availablePort);){if(0!==port)throw new Locked(port);availablePort=await getAvailablePort({...options,port})}return lockedPorts.young.add(availablePort),availablePort}catch(error){if(!(["EADDRINUSE","EACCES"].includes(error.code)||error instanceof Locked))throw error}throw new Error("No available ports found")};getPort.makeRange=(from,to)=>{if(!Number.isInteger(from)||!Number.isInteger(to))throw new TypeError("`from` and `to` must be integer numbers");if(from<1024||from>65535)throw new RangeError("`from` must be between 1024 and 65535");if(to<1024||to>65536)throw new RangeError("`to` must be between 1024 and 65536");if(to<from)throw new RangeError("`to` must be greater than or equal to `from`");return function*(from,to){for(let port=from;port<=to;port++)yield port}(from,to)};var constants={BINARY_TYPES:["nodebuffer","arraybuffer","fragments"],GUID:"258EAFA5-E914-47DA-95CA-C5AB0DC85B11",kStatusCode:Symbol("status-code"),kWebSocket:Symbol("websocket"),EMPTY_BUFFER:Buffer.alloc(0),NOOP:()=>{}},bufferUtil=_commonjsHelpers.createCommonjsModule((function(module){const{EMPTY_BUFFER}=constants;function concat(list,totalLength){if(0===list.length)return EMPTY_BUFFER;if(1===list.length)return list[0];const target=Buffer.allocUnsafe(totalLength);let offset=0;for(let i=0;i<list.length;i++){const buf=list[i];target.set(buf,offset),offset+=buf.length}return offset<totalLength?target.slice(0,offset):target}function _mask(source,mask,output,offset,length){for(let i=0;i<length;i++)output[offset+i]=source[i]^mask[3&i]}function _unmask(buffer,mask){const length=buffer.length;for(let i=0;i<length;i++)buffer[i]^=mask[3&i]}function toArrayBuffer(buf){return buf.byteLength===buf.buffer.byteLength?buf.buffer:buf.buffer.slice(buf.byteOffset,buf.byteOffset+buf.byteLength)}function toBuffer(data){if(toBuffer.readOnly=1,Buffer.isBuffer(data))return data;let buf;return data instanceof ArrayBuffer?buf=Buffer.from(data):ArrayBuffer.isView(data)?buf=function(view){const buf=Buffer.from(view.buffer);if(view.byteLength!==view.buffer.byteLength)return buf.slice(view.byteOffset,view.byteOffset+view.byteLength);return buf}(data):(buf=Buffer.from(data),toBuffer.readOnly=0),buf}try{const bufferUtil=require("bufferutil"),bu=bufferUtil.BufferUtil||bufferUtil;module.exports={concat,mask(source,mask,output,offset,length){length<48?_mask(source,mask,output,offset,length):bu.mask(source,mask,output,offset,length)},toArrayBuffer,toBuffer,unmask(buffer,mask){buffer.length<32?_unmask(buffer,mask):bu.unmask(buffer,mask)}}}catch(e){module.exports={concat,mask:_mask,toArrayBuffer,toBuffer,unmask:_unmask}}}));bufferUtil.concat,bufferUtil.mask,bufferUtil.toArrayBuffer,bufferUtil.toBuffer,bufferUtil.unmask;const kDone=Symbol("kDone"),kRun=Symbol("kRun");var limiter=class{constructor(concurrency){this[kDone]=()=>{this.pending--,this[kRun]()},this.concurrency=concurrency||1/0,this.jobs=[],this.pending=0}add(job){this.jobs.push(job),this[kRun]()}[kRun](){if(this.pending!==this.concurrency&&this.jobs.length){const job=this.jobs.shift();this.pending++,job(this[kDone])}}};const{kStatusCode,NOOP}=constants,TRAILER=Buffer.from([0,0,255,255]),kPerMessageDeflate=Symbol("permessage-deflate"),kTotalLength=Symbol("total-length"),kCallback=Symbol("callback"),kBuffers=Symbol("buffers"),kError=Symbol("error");let zlibLimiter;var permessageDeflate=class{constructor(options,isServer,maxPayload){if(this._maxPayload=0|maxPayload,this._options=options||{},this._threshold=void 0!==this._options.threshold?this._options.threshold:1024,this._isServer=!!isServer,this._deflate=null,this._inflate=null,this.params=null,!zlibLimiter){const concurrency=void 0!==this._options.concurrencyLimit?this._options.concurrencyLimit:10;zlibLimiter=new limiter(concurrency)}}static get extensionName(){return"permessage-deflate"}offer(){const params={};return this._options.serverNoContextTakeover&&(params.server_no_context_takeover=1),this._options.clientNoContextTakeover&&(params.client_no_context_takeover=1),this._options.serverMaxWindowBits&&(params.server_max_window_bits=this._options.serverMaxWindowBits),this._options.clientMaxWindowBits?params.client_max_window_bits=this._options.clientMaxWindowBits:null==this._options.clientMaxWindowBits&&(params.client_max_window_bits=1),params}accept(configurations){return configurations=this.normalizeParams(configurations),this.params=this._isServer?this.acceptAsServer(configurations):this.acceptAsClient(configurations),this.params}cleanup(){this._inflate&&(this._inflate.close(),this._inflate=null),this._deflate&&(this._deflate[kCallback]&&this._deflate[kCallback](),this._deflate.close(),this._deflate=null)}acceptAsServer(offers){const opts=this._options,accepted=offers.find(params=>0==opts.serverNoContextTakeover&&params.server_no_context_takeover||params.server_max_window_bits&&(0==opts.serverMaxWindowBits||"number"==typeof opts.serverMaxWindowBits&&opts.serverMaxWindowBits>params.server_max_window_bits)||"number"==typeof opts.clientMaxWindowBits&&!params.client_max_window_bits?0:1);if(!accepted)throw new Error("None of the extension offers can be accepted");return opts.serverNoContextTakeover&&(accepted.server_no_context_takeover=1),opts.clientNoContextTakeover&&(accepted.client_no_context_takeover=1),"number"==typeof opts.serverMaxWindowBits&&(accepted.server_max_window_bits=opts.serverMaxWindowBits),"number"==typeof opts.clientMaxWindowBits?accepted.client_max_window_bits=opts.clientMaxWindowBits:1!=accepted.client_max_window_bits&&0!=opts.clientMaxWindowBits||delete accepted.client_max_window_bits,accepted}acceptAsClient(response){const params=response[0];if(0==this._options.clientNoContextTakeover&&params.client_no_context_takeover)throw new Error('Unexpected parameter "client_no_context_takeover"');if(params.client_max_window_bits){if(0==this._options.clientMaxWindowBits||"number"==typeof this._options.clientMaxWindowBits&&params.client_max_window_bits>this._options.clientMaxWindowBits)throw new Error('Unexpected or invalid parameter "client_max_window_bits"')}else"number"==typeof this._options.clientMaxWindowBits&&(params.client_max_window_bits=this._options.clientMaxWindowBits);return params}normalizeParams(configurations){return configurations.forEach(params=>{Object.keys(params).forEach(key=>{let value=params[key];if(value.length>1)throw new Error(`Parameter "${key}" must have only a single value`);if(value=value[0],"client_max_window_bits"===key){if(1!=value){const num=+value;if(!Number.isInteger(num)||num<8||num>15)throw new TypeError(`Invalid value for parameter "${key}": ${value}`);value=num}else if(!this._isServer)throw new TypeError(`Invalid value for parameter "${key}": ${value}`)}else if("server_max_window_bits"===key){const num=+value;if(!Number.isInteger(num)||num<8||num>15)throw new TypeError(`Invalid value for parameter "${key}": ${value}`);value=num}else{if("client_no_context_takeover"!==key&&"server_no_context_takeover"!==key)throw new Error(`Unknown parameter "${key}"`);if(1!=value)throw new TypeError(`Invalid value for parameter "${key}": ${value}`)}params[key]=value})}),configurations}decompress(data,fin,callback){zlibLimiter.add(done=>{this._decompress(data,fin,(err,result)=>{done(),callback(err,result)})})}compress(data,fin,callback){zlibLimiter.add(done=>{this._compress(data,fin,(err,result)=>{done(),(err||result)&&callback(err,result)})})}_decompress(data,fin,callback){const endpoint=this._isServer?"client":"server";if(!this._inflate){const key=`${endpoint}_max_window_bits`,windowBits="number"!=typeof this.params[key]?zlib.Z_DEFAULT_WINDOWBITS:this.params[key];this._inflate=zlib.createInflateRaw({...this._options.zlibInflateOptions,windowBits}),this._inflate[kPerMessageDeflate]=this,this._inflate[kTotalLength]=0,this._inflate[kBuffers]=[],this._inflate.on("error",inflateOnError),this._inflate.on("data",inflateOnData)}this._inflate[kCallback]=callback,this._inflate.write(data),fin&&this._inflate.write(TRAILER),this._inflate.flush(()=>{const err=this._inflate[kError];if(err)return this._inflate.close(),this._inflate=null,void callback(err);const data=bufferUtil.concat(this._inflate[kBuffers],this._inflate[kTotalLength]);fin&&this.params[`${endpoint}_no_context_takeover`]?(this._inflate.close(),this._inflate=null):(this._inflate[kTotalLength]=0,this._inflate[kBuffers]=[]),callback(null,data)})}_compress(data,fin,callback){const endpoint=this._isServer?"server":"client";if(!this._deflate){const key=`${endpoint}_max_window_bits`,windowBits="number"!=typeof this.params[key]?zlib.Z_DEFAULT_WINDOWBITS:this.params[key];this._deflate=zlib.createDeflateRaw({...this._options.zlibDeflateOptions,windowBits}),this._deflate[kTotalLength]=0,this._deflate[kBuffers]=[],this._deflate.on("error",NOOP),this._deflate.on("data",deflateOnData)}this._deflate[kCallback]=callback,this._deflate.write(data),this._deflate.flush(zlib.Z_SYNC_FLUSH,()=>{if(!this._deflate)return;let data=bufferUtil.concat(this._deflate[kBuffers],this._deflate[kTotalLength]);fin&&(data=data.slice(0,data.length-4)),this._deflate[kCallback]=null,fin&&this.params[`${endpoint}_no_context_takeover`]?(this._deflate.close(),this._deflate=null):(this._deflate[kTotalLength]=0,this._deflate[kBuffers]=[]),callback(null,data)})}};function deflateOnData(chunk){this[kBuffers].push(chunk),this[kTotalLength]+=chunk.length}function inflateOnData(chunk){this[kTotalLength]+=chunk.length,this[kPerMessageDeflate]._maxPayload<1||this[kTotalLength]<=this[kPerMessageDeflate]._maxPayload?this[kBuffers].push(chunk):(this[kError]=new RangeError("Max payload size exceeded"),this[kError][kStatusCode]=1009,this.removeListener("data",inflateOnData),this.reset())}function inflateOnError(err){this[kPerMessageDeflate]._inflate=null,err[kStatusCode]=1007,this[kCallback](err)}var validation=_commonjsHelpers.createCommonjsModule((function(module,exports){try{const isValidUTF8=require("utf-8-validate");exports.isValidUTF8="object"==typeof isValidUTF8?isValidUTF8.Validation.isValidUTF8:isValidUTF8}catch(e){exports.isValidUTF8=()=>1}exports.isValidStatusCode=code=>code>=1e3&&code<=1013&&1004!==code&&1005!==code&&1006!==code||code>=3e3&&code<=4999}));validation.isValidUTF8,validation.isValidStatusCode;const{Writable}=stream$1,{BINARY_TYPES,EMPTY_BUFFER,kStatusCode:kStatusCode$1,kWebSocket}=constants,{concat,toArrayBuffer,unmask}=bufferUtil,{isValidStatusCode,isValidUTF8}=validation;var receiver=class extends Writable{constructor(binaryType,extensions,maxPayload){super(),this._binaryType=binaryType||BINARY_TYPES[0],this[kWebSocket]=void 0,this._extensions=extensions||{},this._maxPayload=0|maxPayload,this._bufferedBytes=0,this._buffers=[],this._compressed=0,this._payloadLength=0,this._mask=void 0,this._fragmented=0,this._masked=0,this._fin=0,this._opcode=0,this._totalPayloadLength=0,this._messageLength=0,this._fragments=[],this._state=0,this._loop=0}_write(chunk,encoding,cb){if(8===this._opcode&&0==this._state)return cb();this._bufferedBytes+=chunk.length,this._buffers.push(chunk),this.startLoop(cb)}consume(n){if(this._bufferedBytes-=n,n===this._buffers[0].length)return this._buffers.shift();if(n<this._buffers[0].length){const buf=this._buffers[0];return this._buffers[0]=buf.slice(n),buf.slice(0,n)}const dst=Buffer.allocUnsafe(n);do{const buf=this._buffers[0],offset=dst.length-n;n>=buf.length?dst.set(this._buffers.shift(),offset):(dst.set(new Uint8Array(buf.buffer,buf.byteOffset,n),offset),this._buffers[0]=buf.slice(n)),n-=buf.length}while(n>0);return dst}startLoop(cb){let err;this._loop=1;do{switch(this._state){case 0:err=this.getInfo();break;case 1:err=this.getPayloadLength16();break;case 2:err=this.getPayloadLength64();break;case 3:this.getMask();break;case 4:err=this.getData(cb);break;default:return void(this._loop=0)}}while(this._loop);cb(err)}getInfo(){if(this._bufferedBytes<2)return void(this._loop=0);const buf=this.consume(2);if(0!=(48&buf[0]))return this._loop=0,error(RangeError,"RSV2 and RSV3 must be clear",1,1002);const compressed=64==(64&buf[0]);if(compressed&&!this._extensions[permessageDeflate.extensionName])return this._loop=0,error(RangeError,"RSV1 must be clear",1,1002);if(this._fin=128==(128&buf[0]),this._opcode=15&buf[0],this._payloadLength=127&buf[1],0===this._opcode){if(compressed)return this._loop=0,error(RangeError,"RSV1 must be clear",1,1002);if(!this._fragmented)return this._loop=0,error(RangeError,"invalid opcode 0",1,1002);this._opcode=this._fragmented}else if(1===this._opcode||2===this._opcode){if(this._fragmented)return this._loop=0,error(RangeError,`invalid opcode ${this._opcode}`,1,1002);this._compressed=compressed}else{if(!(this._opcode>7&&this._opcode<11))return this._loop=0,error(RangeError,`invalid opcode ${this._opcode}`,1,1002);if(!this._fin)return this._loop=0,error(RangeError,"FIN must be set",1,1002);if(compressed)return this._loop=0,error(RangeError,"RSV1 must be clear",1,1002);if(this._payloadLength>125)return this._loop=0,error(RangeError,`invalid payload length ${this._payloadLength}`,1,1002)}if(this._fin||this._fragmented||(this._fragmented=this._opcode),this._masked=128==(128&buf[1]),126===this._payloadLength)this._state=1;else{if(127!==this._payloadLength)return this.haveLength();this._state=2}}getPayloadLength16(){if(!(this._bufferedBytes<2))return this._payloadLength=this.consume(2).readUInt16BE(0),this.haveLength();this._loop=0}getPayloadLength64(){if(this._bufferedBytes<8)return void(this._loop=0);const buf=this.consume(8),num=buf.readUInt32BE(0);return num>Math.pow(2,21)-1?(this._loop=0,error(RangeError,"Unsupported WebSocket frame: payload length > 2^53 - 1",0,1009)):(this._payloadLength=num*Math.pow(2,32)+buf.readUInt32BE(4),this.haveLength())}haveLength(){if(this._payloadLength&&this._opcode<8&&(this._totalPayloadLength+=this._payloadLength,this._totalPayloadLength>this._maxPayload&&this._maxPayload>0))return this._loop=0,error(RangeError,"Max payload size exceeded",0,1009);this._masked?this._state=3:this._state=4}getMask(){this._bufferedBytes<4?this._loop=0:(this._mask=this.consume(4),this._state=4)}getData(cb){let data=EMPTY_BUFFER;if(this._payloadLength){if(this._bufferedBytes<this._payloadLength)return void(this._loop=0);data=this.consume(this._payloadLength),this._masked&&unmask(data,this._mask)}return this._opcode>7?this.controlMessage(data):this._compressed?(this._state=5,void this.decompress(data,cb)):(data.length&&(this._messageLength=this._totalPayloadLength,this._fragments.push(data)),this.dataMessage())}decompress(data,cb){this._extensions[permessageDeflate.extensionName].decompress(data,this._fin,(err,buf)=>{if(err)return cb(err);if(buf.length){if(this._messageLength+=buf.length,this._messageLength>this._maxPayload&&this._maxPayload>0)return cb(error(RangeError,"Max payload size exceeded",0,1009));this._fragments.push(buf)}const er=this.dataMessage();if(er)return cb(er);this.startLoop(cb)})}dataMessage(){if(this._fin){const messageLength=this._messageLength,fragments=this._fragments;if(this._totalPayloadLength=0,this._messageLength=0,this._fragmented=0,this._fragments=[],2===this._opcode){let data;data="nodebuffer"===this._binaryType?concat(fragments,messageLength):"arraybuffer"===this._binaryType?toArrayBuffer(concat(fragments,messageLength)):fragments,this.emit("message",data)}else{const buf=concat(fragments,messageLength);if(!isValidUTF8(buf))return this._loop=0,error(Error,"invalid UTF-8 sequence",1,1007);this.emit("message",buf.toString())}}this._state=0}controlMessage(data){if(8===this._opcode)if(this._loop=0,0===data.length)this.emit("conclude",1005,""),this.end();else{if(1===data.length)return error(RangeError,"invalid payload length 1",1,1002);{const code=data.readUInt16BE(0);if(!isValidStatusCode(code))return error(RangeError,`invalid status code ${code}`,1,1002);const buf=data.slice(2);if(!isValidUTF8(buf))return error(Error,"invalid UTF-8 sequence",1,1007);this.emit("conclude",code,buf.toString()),this.end()}}else 9===this._opcode?this.emit("ping",data):this.emit("pong",data);this._state=0}};function error(ErrorCtor,message,prefix,statusCode){const err=new ErrorCtor(prefix?`Invalid WebSocket frame: ${message}`:message);return Error.captureStackTrace(err,error),err[kStatusCode$1]=statusCode,err}const{randomFillSync}=crypto,{EMPTY_BUFFER:EMPTY_BUFFER$1}=constants,{isValidStatusCode:isValidStatusCode$1}=validation,{mask:applyMask,toBuffer}=bufferUtil,mask=Buffer.alloc(4);class Sender{constructor(socket,extensions){this._extensions=extensions||{},this._socket=socket,this._firstFragment=1,this._compress=0,this._bufferedBytes=0,this._deflating=0,this._queue=[]}static frame(data,options){const merge=options.mask&&options.readOnly;let offset=options.mask?6:2,payloadLength=data.length;data.length>=65536?(offset+=8,payloadLength=127):data.length>125&&(offset+=2,payloadLength=126);const target=Buffer.allocUnsafe(merge?data.length+offset:offset);return target[0]=options.fin?128|options.opcode:options.opcode,options.rsv1&&(target[0]|=64),target[1]=payloadLength,126===payloadLength?target.writeUInt16BE(data.length,2):127===payloadLength&&(target.writeUInt32BE(0,2),target.writeUInt32BE(data.length,6)),options.mask?(randomFillSync(mask,0,4),target[1]|=128,target[offset-4]=mask[0],target[offset-3]=mask[1],target[offset-2]=mask[2],target[offset-1]=mask[3],merge?(applyMask(data,mask,target,offset,data.length),[target]):(applyMask(data,mask,data,0,data.length),[target,data])):[target,data]}close(code,data,mask,cb){let buf;if(void 0===code)buf=EMPTY_BUFFER$1;else{if("number"!=typeof code||!isValidStatusCode$1(code))throw new TypeError("First argument must be a valid error code number");void 0===data||""===data?(buf=Buffer.allocUnsafe(2),buf.writeUInt16BE(code,0)):(buf=Buffer.allocUnsafe(2+Buffer.byteLength(data)),buf.writeUInt16BE(code,0),buf.write(data,2))}this._deflating?this.enqueue([this.doClose,buf,mask,cb]):this.doClose(buf,mask,cb)}doClose(data,mask,cb){this.sendFrame(Sender.frame(data,{fin:1,rsv1:0,opcode:8,mask,readOnly:0}),cb)}ping(data,mask,cb){const buf=toBuffer(data);this._deflating?this.enqueue([this.doPing,buf,mask,toBuffer.readOnly,cb]):this.doPing(buf,mask,toBuffer.readOnly,cb)}doPing(data,mask,readOnly,cb){this.sendFrame(Sender.frame(data,{fin:1,rsv1:0,opcode:9,mask,readOnly}),cb)}pong(data,mask,cb){const buf=toBuffer(data);this._deflating?this.enqueue([this.doPong,buf,mask,toBuffer.readOnly,cb]):this.doPong(buf,mask,toBuffer.readOnly,cb)}doPong(data,mask,readOnly,cb){this.sendFrame(Sender.frame(data,{fin:1,rsv1:0,opcode:10,mask,readOnly}),cb)}send(data,options,cb){const buf=toBuffer(data),perMessageDeflate=this._extensions[permessageDeflate.extensionName];let opcode=options.binary?2:1,rsv1=options.compress;if(this._firstFragment?(this._firstFragment=0,rsv1&&perMessageDeflate&&(rsv1=buf.length>=perMessageDeflate._threshold),this._compress=rsv1):(rsv1=0,opcode=0),options.fin&&(this._firstFragment=1),perMessageDeflate){const opts={fin:options.fin,rsv1,opcode,mask:options.mask,readOnly:toBuffer.readOnly};this._deflating?this.enqueue([this.dispatch,buf,this._compress,opts,cb]):this.dispatch(buf,this._compress,opts,cb)}else this.sendFrame(Sender.frame(buf,{fin:options.fin,rsv1:0,opcode,mask:options.mask,readOnly:toBuffer.readOnly}),cb)}dispatch(data,compress,options,cb){if(!compress)return void this.sendFrame(Sender.frame(data,options),cb);const perMessageDeflate=this._extensions[permessageDeflate.extensionName];this._deflating=1,perMessageDeflate.compress(data,options.fin,(_,buf)=>{this._deflating=0,options.readOnly=0,this.sendFrame(Sender.frame(buf,options),cb),this.dequeue()})}dequeue(){for(;!this._deflating&&this._queue.length;){const params=this._queue.shift();this._bufferedBytes-=params[1].length,Reflect.apply(params[0],this,params.slice(1))}}enqueue(params){this._bufferedBytes+=params[1].length,this._queue.push(params)}sendFrame(list,cb){2===list.length?(this._socket.cork(),this._socket.write(list[0]),this._socket.write(list[1],cb),this._socket.uncork()):this._socket.write(list[0],cb)}}var sender=Sender;class Event{constructor(type,target){this.target=target,this.type=type}}class MessageEvent extends Event{constructor(data,target){super("message",target),this.data=data}}class CloseEvent extends Event{constructor(code,reason,target){super("close",target),this.wasClean=target._closeFrameReceived&&target._closeFrameSent,this.reason=reason,this.code=code}}class OpenEvent extends Event{constructor(target){super("open",target)}}class ErrorEvent extends Event{constructor(error,target){super("error",target),this.message=error.message,this.error=error}}var eventTarget={addEventListener(method,listener){function onMessage(data){listener.call(this,new MessageEvent(data,this))}function onClose(code,message){listener.call(this,new CloseEvent(code,message,this))}function onError(error){listener.call(this,new ErrorEvent(error,this))}function onOpen(){listener.call(this,new OpenEvent(this))}"function"==typeof listener&&("message"===method?(onMessage._listener=listener,this.on(method,onMessage)):"close"===method?(onClose._listener=listener,this.on(method,onClose)):"error"===method?(onError._listener=listener,this.on(method,onError)):"open"===method?(onOpen._listener=listener,this.on(method,onOpen)):this.on(method,listener))},removeEventListener(method,listener){const listeners=this.listeners(method);for(let i=0;i<listeners.length;i++)listeners[i]!==listener&&listeners[i]._listener!==listener||this.removeListener(method,listeners[i])}};const tokenChars=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0];function push(dest,name,elem){void 0===dest[name]?dest[name]=[elem]:dest[name].push(elem)}var extension={format:function(extensions){return Object.keys(extensions).map(extension=>{let configurations=extensions[extension];return Array.isArray(configurations)||(configurations=[configurations]),configurations.map(params=>[extension].concat(Object.keys(params).map(k=>{let values=params[k];return Array.isArray(values)||(values=[values]),values.map(v=>1==v?k:`${k}=${v}`).join("; ")})).join("; ")).join(", ")}).join(", ")},parse:function(header){const offers=Object.create(null);if(void 0===header||""===header)return offers;let extensionName,paramName,params=Object.create(null),inQuotes=0,start=-1,end=-1,i=0;for(;i<header.length;i++){const code=header.charCodeAt(i);if(void 0===extensionName)if(-1===end&&1===tokenChars[code])-1===start&&(start=i);else if(32===code||9===code)-1===end&&-1!==start&&(end=i);else{if(59!==code&&44!==code)throw new SyntaxError(`Unexpected character at index ${i}`);{if(-1===start)throw new SyntaxError(`Unexpected character at index ${i}`);-1===end&&(end=i);const name=header.slice(start,end);44===code?(push(offers,name,params),params=Object.create(null)):extensionName=name,start=end=-1}}else if(void 0===paramName)if(-1===end&&1===tokenChars[code])-1===start&&(start=i);else if(32===code||9===code)-1===end&&-1!==start&&(end=i);else if(59===code||44===code){if(-1===start)throw new SyntaxError(`Unexpected character at index ${i}`);-1===end&&(end=i),push(params,header.slice(start,end),1),44===code&&(push(offers,extensionName,params),params=Object.create(null),extensionName=void 0),start=end=-1}else{if(61!==code||-1===start||-1!==end)throw new SyntaxError(`Unexpected character at index ${i}`);paramName=header.slice(start,i),start=end=-1}else 1}if(-1===start||inQuotes)throw new SyntaxError("Unexpected end of input");-1===end&&(end=i);const token=header.slice(start,end);return void 0===extensionName?push(offers,token,params):(void 0===paramName?push(params,token,1):push(params,paramName,token),push(offers,extensionName,params)),offers}};const{randomBytes,createHash}=crypto,{URL}=url,{BINARY_TYPES:BINARY_TYPES$1,EMPTY_BUFFER:EMPTY_BUFFER$2,GUID,kStatusCode:kStatusCode$2,kWebSocket:kWebSocket$1,NOOP:NOOP$1}=constants,{addEventListener,removeEventListener}=eventTarget,{format:format$1,parse:parse$1}=extension,{toBuffer:toBuffer$1}=bufferUtil,readyStates=["CONNECTING","OPEN","CLOSING","CLOSED"],protocolVersions=[8,13];class WebSocket extends events{constructor(address,protocols,options){super(),this.readyState=WebSocket.CONNECTING,this.protocol="",this._binaryType=BINARY_TYPES$1[0],this._closeFrameReceived=0,this._closeFrameSent=0,this._closeMessage="",this._closeTimer=null,this._closeCode=1006,this._extensions={},this._receiver=null,this._sender=null,this._socket=null,null!==address?(this._bufferedAmount=0,this._isServer=0,this._redirects=0,Array.isArray(protocols)?protocols=protocols.join(", "):"object"==typeof protocols&&null!==protocols&&(options=protocols,protocols=void 0),function initAsClient(websocket,address,protocols,options){const opts={protocolVersion:protocolVersions[1],maxPayload:104857600,perMessageDeflate:1,followRedirects:0,maxRedirects:10,...options,createConnection:void 0,socketPath:void 0,hostname:void 0,protocol:void 0,timeout:void 0,method:void 0,auth:void 0,host:void 0,path:void 0,port:void 0};if(!protocolVersions.includes(opts.protocolVersion))throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} `+`(supported versions: ${protocolVersions.join(", ")})`);let parsedUrl;address instanceof URL?(parsedUrl=address,websocket.url=address.href):(parsedUrl=new URL(address),websocket.url=address);const isUnixSocket="ws+unix:"===parsedUrl.protocol;if(!(parsedUrl.host||isUnixSocket&&parsedUrl.pathname))throw new Error(`Invalid URL: ${websocket.url}`);const isSecure="wss:"===parsedUrl.protocol||"https:"===parsedUrl.protocol,defaultPort=isSecure?443:80,key=randomBytes(16).toString("base64"),get=isSecure?https__default.get:http__default.get;let perMessageDeflate;opts.createConnection=isSecure?tlsConnect:netConnect,opts.defaultPort=opts.defaultPort||defaultPort,opts.port=parsedUrl.port||defaultPort,opts.host=parsedUrl.hostname.startsWith("[")?parsedUrl.hostname.slice(1,-1):parsedUrl.hostname,opts.headers={"Sec-WebSocket-Version":opts.protocolVersion,"Sec-WebSocket-Key":key,Connection:"Upgrade",Upgrade:"websocket",...opts.headers},opts.path=parsedUrl.pathname+parsedUrl.search,opts.timeout=opts.handshakeTimeout,opts.perMessageDeflate&&(perMessageDeflate=new permessageDeflate(1!=opts.perMessageDeflate?opts.perMessageDeflate:{},0,opts.maxPayload),opts.headers["Sec-WebSocket-Extensions"]=format$1({[permessageDeflate.extensionName]:perMessageDeflate.offer()}));protocols&&(opts.headers["Sec-WebSocket-Protocol"]=protocols);opts.origin&&(opts.protocolVersion<13?opts.headers["Sec-WebSocket-Origin"]=opts.origin:opts.headers.Origin=opts.origin);(parsedUrl.username||parsedUrl.password)&&(opts.auth=`${parsedUrl.username}:${parsedUrl.password}`);if(isUnixSocket){const parts=opts.path.split(":");opts.socketPath=parts[0],opts.path=parts[1]}let req=websocket._req=get(opts);opts.timeout&&req.on("timeout",()=>{abortHandshake(websocket,req,"Opening handshake has timed out")});req.on("error",err=>{websocket._req.aborted||(req=websocket._req=null,websocket.readyState=WebSocket.CLOSING,websocket.emit("error",err),websocket.emitClose())}),req.on("response",res=>{const location=res.headers.location,statusCode=res.statusCode;if(location&&opts.followRedirects&&statusCode>=300&&statusCode<400){if(++websocket._redirects>opts.maxRedirects)return void abortHandshake(websocket,req,"Maximum redirects exceeded");req.abort();const addr=new URL(location,address);initAsClient(websocket,addr,protocols,options)}else websocket.emit("unexpected-response",req,res)||abortHandshake(websocket,req,`Unexpected server response: ${res.statusCode}`)}),req.on("upgrade",(res,socket,head)=>{if(websocket.emit("upgrade",res),websocket.readyState!==WebSocket.CONNECTING)return;req=websocket._req=null;const digest=createHash("sha1").update(key+GUID).digest("base64");if(res.headers["sec-websocket-accept"]!==digest)return void abortHandshake(websocket,socket,"Invalid Sec-WebSocket-Accept header");const serverProt=res.headers["sec-websocket-protocol"],protList=(protocols||"").split(/, */);let protError;if(!protocols&&serverProt?protError="Server sent a subprotocol but none was requested":protocols&&!serverProt?protError="Server sent no subprotocol":serverProt&&!protList.includes(serverProt)&&(protError="Server sent an invalid subprotocol"),protError)abortHandshake(websocket,socket,protError);else{if(serverProt&&(websocket.protocol=serverProt),perMessageDeflate)try{const extensions=parse$1(res.headers["sec-websocket-extensions"]);extensions[permessageDeflate.extensionName]&&(perMessageDeflate.accept(extensions[permessageDeflate.extensionName]),websocket._extensions[permessageDeflate.extensionName]=perMessageDeflate)}catch(err){return void abortHandshake(websocket,socket,"Invalid Sec-WebSocket-Extensions header")}websocket.setSocket(socket,head,opts.maxPayload)}})}(this,address,protocols,options)):this._isServer=1}get CONNECTING(){return WebSocket.CONNECTING}get CLOSING(){return WebSocket.CLOSING}get CLOSED(){return WebSocket.CLOSED}get OPEN(){return WebSocket.OPEN}get binaryType(){return this._binaryType}set binaryType(type){BINARY_TYPES$1.includes(type)&&(this._binaryType=type,this._receiver&&(this._receiver._binaryType=type))}get bufferedAmount(){return this._socket?(this._socket.bufferSize||0)+this._sender._bufferedBytes:this._bufferedAmount}get extensions(){return Object.keys(this._extensions).join()}setSocket(socket,head,maxPayload){const receiver$1=new receiver(this._binaryType,this._extensions,maxPayload);this._sender=new sender(socket,this._extensions),this._receiver=receiver$1,this._socket=socket,receiver$1[kWebSocket$1]=this,socket[kWebSocket$1]=this,receiver$1.on("conclude",receiverOnConclude),receiver$1.on("drain",receiverOnDrain),receiver$1.on("error",receiverOnError),receiver$1.on("message",receiverOnMessage),receiver$1.on("ping",receiverOnPing),receiver$1.on("pong",receiverOnPong),socket.setTimeout(0),socket.setNoDelay(),head.length>0&&socket.unshift(head),socket.on("close",socketOnClose),socket.on("data",socketOnData),socket.on("end",socketOnEnd),socket.on("error",socketOnError),this.readyState=WebSocket.OPEN,this.emit("open")}emitClose(){this.readyState=WebSocket.CLOSED,this._socket?(this._extensions[permessageDeflate.extensionName]&&this._extensions[permessageDeflate.extensionName].cleanup(),this._receiver.removeAllListeners(),this.emit("close",this._closeCode,this._closeMessage)):this.emit("close",this._closeCode,this._closeMessage)}close(code,data){if(this.readyState!==WebSocket.CLOSED){if(this.readyState===WebSocket.CONNECTING){const msg="WebSocket was closed before the connection was established";return abortHandshake(this,this._req,msg)}this.readyState!==WebSocket.CLOSING?(this.readyState=WebSocket.CLOSING,this._sender.close(code,data,!this._isServer,err=>{err||(this._closeFrameSent=1,this._closeFrameReceived&&this._socket.end())}),this._closeTimer=setTimeout(this._socket.destroy.bind(this._socket),3e4)):this._closeFrameSent&&this._closeFrameReceived&&this._socket.end()}}ping(data,mask,cb){if(this.readyState===WebSocket.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");"function"==typeof data?(cb=data,data=mask=void 0):"function"==typeof mask&&(cb=mask,mask=void 0),"number"==typeof data&&(data=data.toString()),this.readyState===WebSocket.OPEN?(void 0===mask&&(mask=!this._isServer),this._sender.ping(data||EMPTY_BUFFER$2,mask,cb)):sendAfterClose(this,data,cb)}pong(data,mask,cb){if(this.readyState===WebSocket.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");"function"==typeof data?(cb=data,data=mask=void 0):"function"==typeof mask&&(cb=mask,mask=void 0),"number"==typeof data&&(data=data.toString()),this.readyState===WebSocket.OPEN?(void 0===mask&&(mask=!this._isServer),this._sender.pong(data||EMPTY_BUFFER$2,mask,cb)):sendAfterClose(this,data,cb)}send(data,options,cb){if(this.readyState===WebSocket.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if("function"==typeof options&&(cb=options,options={}),"number"==typeof data&&(data=data.toString()),this.readyState!==WebSocket.OPEN)return void sendAfterClose(this,data,cb);const opts={binary:"string"!=typeof data,mask:!this._isServer,compress:1,fin:1,...options};this._extensions[permessageDeflate.extensionName]||(opts.compress=0),this._sender.send(data||EMPTY_BUFFER$2,opts,cb)}terminate(){if(this.readyState!==WebSocket.CLOSED){if(this.readyState===WebSocket.CONNECTING){const msg="WebSocket was closed before the connection was established";return abortHandshake(this,this._req,msg)}this._socket&&(this.readyState=WebSocket.CLOSING,this._socket.destroy())}}}readyStates.forEach((readyState,i)=>{WebSocket[readyState]=i}),["open","error","close","message"].forEach(method=>{Object.defineProperty(WebSocket.prototype,`on${method}`,{get(){const listeners=this.listeners(method);for(let i=0;i<listeners.length;i++)if(listeners[i]._listener)return listeners[i]._listener},set(listener){const listeners=this.listeners(method);for(let i=0;i<listeners.length;i++)listeners[i]._listener&&this.removeListener(method,listeners[i]);this.addEventListener(method,listener)}})}),WebSocket.prototype.addEventListener=addEventListener,WebSocket.prototype.removeEventListener=removeEventListener;var websocket=WebSocket;function netConnect(options){return options.path=options.socketPath,net.connect(options)}function tlsConnect(options){return options.path=void 0,options.servername||""===options.servername||(options.servername=options.host),tls.connect(options)}function abortHandshake(websocket,stream,message){websocket.readyState=WebSocket.CLOSING;const err=new Error(message);Error.captureStackTrace(err,abortHandshake),stream.setHeader?(stream.abort(),stream.once("abort",websocket.emitClose.bind(websocket)),websocket.emit("error",err)):(stream.destroy(err),stream.once("error",websocket.emit.bind(websocket,"error")),stream.once("close",websocket.emitClose.bind(websocket)))}function sendAfterClose(websocket,data,cb){if(data){const length=toBuffer$1(data).length;websocket._socket?websocket._sender._bufferedBytes+=length:websocket._bufferedAmount+=length}if(cb){cb(new Error(`WebSocket is not open: readyState ${websocket.readyState} `+`(${readyStates[websocket.readyState]})`))}}function receiverOnConclude(code,reason){const websocket=this[kWebSocket$1];websocket._socket.removeListener("data",socketOnData),websocket._socket.resume(),websocket._closeFrameReceived=1,websocket._closeMessage=reason,websocket._closeCode=code,1005===code?websocket.close():websocket.close(code,reason)}function receiverOnDrain(){this[kWebSocket$1]._socket.resume()}function receiverOnError(err){const websocket=this[kWebSocket$1];websocket._socket.removeListener("data",socketOnData),websocket.readyState=WebSocket.CLOSING,websocket._closeCode=err[kStatusCode$2],websocket.emit("error",err),websocket._socket.destroy()}function receiverOnFinish(){this[kWebSocket$1].emitClose()}function receiverOnMessage(data){this[kWebSocket$1].emit("message",data)}function receiverOnPing(data){const websocket=this[kWebSocket$1];websocket.pong(data,!websocket._isServer,NOOP$1),websocket.emit("ping",data)}function receiverOnPong(data){this[kWebSocket$1].emit("pong",data)}function socketOnClose(){const websocket=this[kWebSocket$1];this.removeListener("close",socketOnClose),this.removeListener("end",socketOnEnd),websocket.readyState=WebSocket.CLOSING,websocket._socket.read(),websocket._receiver.end(),this.removeListener("data",socketOnData),this[kWebSocket$1]=void 0,clearTimeout(websocket._closeTimer),websocket._receiver._writableState.finished||websocket._receiver._writableState.errorEmitted?websocket.emitClose():(websocket._receiver.on("error",receiverOnFinish),websocket._receiver.on("finish",receiverOnFinish))}function socketOnData(chunk){this[kWebSocket$1]._receiver.write(chunk)||this.pause()}function socketOnEnd(){const websocket=this[kWebSocket$1];websocket.readyState=WebSocket.CLOSING,websocket._receiver.end(),this.end()}function socketOnError(){const websocket=this[kWebSocket$1];this.removeListener("error",socketOnError),this.on("error",NOOP$1),websocket&&(websocket.readyState=WebSocket.CLOSING,this.destroy())}const{Duplex}=stream$1;function emitClose(stream){stream.emit("close")}function duplexOnEnd(){!this.destroyed&&this._writableState.finished&&this.destroy()}function duplexOnError(err){this.removeListener("error",duplexOnError),this.destroy(),0===this.listenerCount("error")&&this.emit("error",err)}var stream=function(ws,options){let resumeOnReceiverDrain=1;function receiverOnDrain(){resumeOnReceiverDrain&&ws._socket.resume()}ws.readyState===ws.CONNECTING?ws.once("open",(function(){ws._receiver.removeAllListeners("drain"),ws._receiver.on("drain",receiverOnDrain)})):(ws._receiver.removeAllListeners("drain"),ws._receiver.on("drain",receiverOnDrain));const duplex=new Duplex({...options,autoDestroy:0,emitClose:0,objectMode:0,writableObjectMode:0});return ws.on("message",(function(msg){duplex.push(msg)||(resumeOnReceiverDrain=0,ws._socket.pause())})),ws.once("error",(function(err){duplex.destroy(err)})),ws.once("close",(function(){duplex.destroyed||duplex.push(null)})),duplex._destroy=function(err,callback){if(ws.readyState===ws.CLOSED)return callback(err),void process.nextTick(emitClose,duplex);ws.once("close",(function(){callback(err),process.nextTick(emitClose,duplex)})),ws.terminate()},duplex._final=function(callback){ws.readyState!==ws.CONNECTING?ws._socket._writableState.finished?(duplex._readableState.endEmitted&&duplex.destroy(),callback()):(ws._socket.once("finish",(function(){callback()})),ws.close()):ws.once("open",(function(){duplex._final(callback)}))},duplex._read=function(){ws.readyState!==ws.OPEN||resumeOnReceiverDrain||(resumeOnReceiverDrain=1,ws._receiver._writableState.needDrain||ws._socket.resume())},duplex._write=function(chunk,encoding,callback){ws.readyState!==ws.CONNECTING?ws.send(chunk,callback):ws.once("open",(function(){duplex._write(chunk,encoding,callback)}))},duplex.on("end",duplexOnEnd),duplex.on("error",duplexOnError),duplex};const{createHash:createHash$1}=crypto,{createServer,STATUS_CODES}=http__default,{format:format$2,parse:parse$2}=extension,{GUID:GUID$1}=constants,keyRegex=/^[+/0-9A-Za-z]{22}==$/,kUsedByWebSocketServer=Symbol("kUsedByWebSocketServer");var websocketServer=class extends events{constructor(options,callback){if(super(),null==(options={maxPayload:104857600,perMessageDeflate:0,handleProtocols:null,clientTracking:1,verifyClient:null,noServer:0,backlog:null,server:null,host:null,path:null,port:null,...options}).port&&!options.server&&!options.noServer)throw new TypeError('One of the "port", "server", or "noServer" options must be specified');if(null!=options.port)this._server=createServer((req,res)=>{const body=STATUS_CODES[426];res.writeHead(426,{"Content-Length":body.length,"Content-Type":"text/plain"}),res.end(body)}),this._server.listen(options.port,options.host,options.backlog,callback);else if(options.server){if(options.server[kUsedByWebSocketServer])throw new Error("The HTTP/S server is already being used by another WebSocket server");options.server[kUsedByWebSocketServer]=1,this._server=options.server}this._server&&(this._removeListeners=function(server,map){for(const event of Object.keys(map))server.on(event,map[event]);return function(){for(const event of Object.keys(map))server.removeListener(event,map[event])}}(this._server,{listening:this.emit.bind(this,"listening"),error:this.emit.bind(this,"error"),upgrade:(req,socket,head)=>{this.handleUpgrade(req,socket,head,ws=>{this.emit("connection",ws,req)})}})),1==options.perMessageDeflate&&(options.perMessageDeflate={}),options.clientTracking&&(this.clients=new Set),this.options=options}address(){if(this.options.noServer)throw new Error('The server is operating in "noServer" mode');return this._server?this._server.address():null}close(cb){if(cb&&this.once("close",cb),this.clients)for(const client of this.clients)client.terminate();const server=this._server;if(server){if(this._removeListeners(),this._removeListeners=this._server=null,null!=this.options.port)return void server.close(()=>this.emit("close"));delete server[kUsedByWebSocketServer]}process.nextTick(emitClose$1,this)}shouldHandle(req){if(this.options.path){const index=req.url.indexOf("?");if((-1!==index?req.url.slice(0,index):req.url)!==this.options.path)return 0}return 1}handleUpgrade(req,socket,head,cb){socket.on("error",socketOnError$1);const key=void 0!==req.headers["sec-websocket-key"]?req.headers["sec-websocket-key"].trim():0,version=+req.headers["sec-websocket-version"],extensions={};if("GET"!==req.method||"websocket"!==req.headers.upgrade.toLowerCase()||!key||!keyRegex.test(key)||8!==version&&13!==version||!this.shouldHandle(req))return abortHandshake$1(socket,400);if(this.options.perMessageDeflate){const perMessageDeflate=new permessageDeflate(this.options.perMessageDeflate,1,this.options.maxPayload);try{const offers=parse$2(req.headers["sec-websocket-extensions"]);offers[permessageDeflate.extensionName]&&(perMessageDeflate.accept(offers[permessageDeflate.extensionName]),extensions[permessageDeflate.extensionName]=perMessageDeflate)}catch(err){return abortHandshake$1(socket,400)}}if(this.options.verifyClient){const info={origin:req.headers[`${8===version?"sec-websocket-origin":"origin"}`],secure:!(!req.connection.authorized&&!req.connection.encrypted),req};if(2===this.options.verifyClient.length)return void this.options.verifyClient(info,(verified,code,message,headers)=>{if(!verified)return abortHandshake$1(socket,code||401,message,headers);this.completeUpgrade(key,extensions,req,socket,head,cb)});if(!this.options.verifyClient(info))return abortHandshake$1(socket,401)}this.completeUpgrade(key,extensions,req,socket,head,cb)}completeUpgrade(key,extensions,req,socket,head,cb){if(!socket.readable||!socket.writable)return socket.destroy();const headers=["HTTP/1.1 101 Switching Protocols","Upgrade: websocket","Connection: Upgrade",`Sec-WebSocket-Accept: ${createHash$1("sha1").update(key+GUID$1).digest("base64")}`],ws=new websocket(null);let protocol=req.headers["sec-websocket-protocol"];if(protocol&&(protocol=protocol.trim().split(/ *, */),protocol=this.options.handleProtocols?this.options.handleProtocols(protocol,req):protocol[0],protocol&&(headers.push(`Sec-WebSocket-Protocol: ${protocol}`),ws.protocol=protocol)),extensions[permessageDeflate.extensionName]){const params=extensions[permessageDeflate.extensionName].params,value=format$2({[permessageDeflate.extensionName]:[params]});headers.push(`Sec-WebSocket-Extensions: ${value}`),ws._extensions=extensions}this.emit("headers",headers,req),socket.write(headers.concat("\r\n").join("\r\n")),socket.removeListener("error",socketOnError$1),ws.setSocket(socket,head,this.options.maxPayload),this.clients&&(this.clients.add(ws),ws.on("close",()=>this.clients.delete(ws))),cb(ws)}};function emitClose$1(server){server.emit("close")}function socketOnError$1(){this.destroy()}function abortHandshake$1(socket,code,message,headers){socket.writable&&(message=message||STATUS_CODES[code],headers={Connection:"close","Content-type":"text/html","Content-Length":Buffer.byteLength(message),...headers},socket.write(`HTTP/1.1 ${code} ${STATUS_CODES[code]}\r\n`+Object.keys(headers).map(h=>`${h}: ${headers[h]}`).join("\r\n")+"\r\n\r\n"+message)),socket.removeListener("error",socketOnError$1),socket.destroy()}websocket.createWebSocketStream=stream,websocket.Server=websocketServer,websocket.Receiver=receiver,websocket.Sender=sender;var ws=websocket;const webSocketServer=function(){let webSocketServer;const lastCommands={},eventEmitter=function(){let listeners={};return{addListener(event,callback){listeners[event]||(listeners[event]=new Set),listeners[event].add(callback)},emit(event,...args){for(const listener of listeners[event])listener(...args)},removeListener(event,callback){listeners[event].delete(callback)},removeAllListeners(){listeners=void 0}}}();return{get port(){return webSocketServer.options.port},addListener:eventEmitter.addListener,broadcast(message,{skip}={}){for(const{command,payload}of message)lastCommands[command]=payload;const stringifiedMessage=JSON.stringify(message);for(const client of webSocketServer.clients)skip!==client&&client.readyState===ws.OPEN&&client.send(stringifiedMessage)},start(port=3e3){webSocketServer=new ws.Server({port}),webSocketServer.on("connection",websocket=>{const stringifiedMessage=JSON.stringify(Object.entries(lastCommands).map(([key,value])=>({command:key,payload:value})));stringifiedMessage&&websocket.send(stringifiedMessage),websocket.on("message",message=>{eventEmitter.emit("message",message,websocket)})})},stop(){eventEmitter.removeAllListeners(),webSocketServer.close()}}}(),previewWebSocketServer={get port(){return webSocketServer.port},broadcast(messages){webSocketServer.broadcast(messages)},async start(){const port=await getPort();webSocketServer.start(port)},stop(){webSocketServer.stop()}};exports.previewWebSocketServer=previewWebSocketServer;
//# sourceMappingURL=previewWebSocketServer-f4cf08fb.js.map
