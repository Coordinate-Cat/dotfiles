import { Hub } from '@sentry/hub';
import { EventProcessor, Integration, Span, SpanContext, TransactionContext } from '@sentry/types';
import { SpanStatus } from '../spanstatus';
import { Transaction } from '../transaction';
/**
 * Options for Tracing integration
 */
export interface TracingOptions {
    /**
     * List of strings / regex where the integration should create Spans out of. Additionally this will be used
     * to define which outgoing requests the `sentry-trace` header will be attached to.
     *
     * Default: ['localhost', /^\//]
     */
    tracingOrigins: Array<string | RegExp>;
    /**
     * Flag to disable patching all together for fetch requests.
     *
     * Default: true
     */
    traceFetch: boolean;
    /**
     * Flag to disable patching all together for xhr requests.
     *
     * Default: true
     */
    traceXHR: boolean;
    /**
     * This function will be called before creating a span for a request with the given url.
     * Return false if you don't want a span for the given url.
     *
     * By default it uses the `tracingOrigins` options as a url match.
     */
    shouldCreateSpanForRequest(url: string): boolean;
    /**
     * The time to wait in ms until the transaction will be finished. The transaction will use the end timestamp of
     * the last finished span as the endtime for the transaction.
     * Time is in ms.
     *
     * Default: 500
     */
    idleTimeout: number;
    /**
     * Flag to enable/disable creation of `navigation` transaction on history changes. Useful for react applications with
     * a router.
     *
     * Default: true
     */
    startTransactionOnLocationChange: boolean;
    /**
     * Flag to enable/disable creation of `pageload` transaction on first pageload.
     *
     * Default: true
     */
    startTransactionOnPageLoad: boolean;
    /**
     * The maximum duration of a transaction before it will be marked as "deadline_exceeded".
     * If you never want to mark a transaction set it to 0.
     * Time is in seconds.
     *
     * Default: 600
     */
    maxTransactionDuration: number;
    /**
     * Flag Transactions where tabs moved to background with "cancelled". Browser background tab timing is
     * not suited towards doing precise measurements of operations. Background transaction can mess up your
     * statistics in non deterministic ways that's why we by default recommend leaving this opition enabled.
     *
     * Default: true
     */
    markBackgroundTransactions: boolean;
    /**
     * This is only if you want to debug in prod.
     * writeAsBreadcrumbs: Instead of having console.log statements we log messages to breadcrumbs
     * so you can investigate whats happening in production with your users to figure why things might not appear the
     * way you expect them to.
     *
     * spanDebugTimingInfo: Add timing info to spans at the point where we create them to figure out browser timing
     * issues.
     *
     * You shouldn't care about this.
     *
     * Default: {
     *   writeAsBreadcrumbs: false;
     *   spanDebugTimingInfo: false;
     * }
     */
    debug: {
        writeAsBreadcrumbs: boolean;
        spanDebugTimingInfo: boolean;
    };
    /**
     * beforeNavigate is called before a pageload/navigation transaction is created and allows for users
     * to set a custom navigation transaction name based on the current `window.location`. Defaults to returning
     * `window.location.pathname`.
     *
     * @param location the current location before navigation span is created
     */
    beforeNavigate(location: Location): string;
}
/** JSDoc */
interface Activity {
    name: string;
    span?: Span;
}
/**
 * Tracing Integration
 */
export declare class Tracing implements Integration {
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    static id: string;
    /** JSDoc */
    static options: TracingOptions;
    /**
     * Returns current hub.
     */
    private static _getCurrentHub?;
    private static _activeTransaction?;
    private static _currentIndex;
    static _activities: {
        [key: number]: Activity;
    };
    private readonly _emitOptionsWarning;
    private static _performanceCursor;
    private static _heartbeatTimer;
    private static _prevHeartbeatString;
    private static _heartbeatCounter;
    /** Holds the latest LargestContentfulPaint value (it changes during page load). */
    private static _lcp?;
    /** Force any pending LargestContentfulPaint records to be dispatched. */
    private static _forceLCP;
    /**
     * Constructor for Tracing
     *
     * @param _options TracingOptions
     */
    constructor(_options?: Partial<TracingOptions>);
    /**
     * @inheritDoc
     */
    setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void;
    /**
     * Pings the heartbeat
     */
    private static _pingHeartbeat;
    /**
     * Checks when entries of Tracing._activities are not changing for 3 beats. If this occurs we finish the transaction
     *
     */
    private static _beat;
    /**
     * Discards active transactions if tab moves to background
     */
    private _setupBackgroundTabDetection;
    /**
     * Unsets the current active transaction + activities
     */
    private static _resetActiveTransaction;
    /**
     * Registers to History API to detect navigation changes
     */
    private _setupHistory;
    /**
     * Attaches to fetch to add sentry-trace header + creating spans
     */
    private _setupFetchTracing;
    /**
     * Attaches to XHR to add sentry-trace header + creating spans
     */
    private _setupXHRTracing;
    /**
     * Configures global error listeners
     */
    private _setupErrorHandling;
    /**
     * Uses logger.log to log things in the SDK or as breadcrumbs if defined in options
     */
    private static _log;
    /**
     * Starts a Transaction waiting for activity idle to finish
     */
    static startIdleTransaction(transactionContext: TransactionContext): Transaction | undefined;
    /**
     * Finishes the current active transaction
     */
    static finishIdleTransaction(endTimestamp: number): void;
    /**
     * This uses `performance.getEntries()` to add additional spans to the active transaction.
     * Also, we update our timings since we consider the timings in this API to be more correct than our manual
     * measurements.
     *
     * @param transactionSpan The transaction span
     */
    private static _addPerformanceEntries;
    /**
     * Starts tracking the Largest Contentful Paint on the current page.
     */
    private static _trackLCP;
    /**
     * Sets the status of the current active transaction (if there is one)
     */
    static setTransactionStatus(status: SpanStatus): void;
    /**
     * Returns the current active idle transaction if there is one
     */
    static getTransaction(): Transaction | undefined;
    /**
     * Converts from milliseconds to seconds
     * @param time time in ms
     */
    private static _msToSec;
    /**
     * Adds debug data to the span
     */
    private static _addSpanDebugInfo;
    /**
     * Starts tracking for a specifc activity
     *
     * @param name Name of the activity, can be any string (Only used internally to identify the activity)
     * @param spanContext If provided a Span with the SpanContext will be created.
     * @param options _autoPopAfter_ | Time in ms, if provided the activity will be popped automatically after this timeout. This can be helpful in cases where you cannot gurantee your application knows the state and calls `popActivity` for sure.
     */
    static pushActivity(name: string, spanContext?: SpanContext, options?: {
        autoPopAfter?: number;
    }): number;
    /**
     * Removes activity and finishes the span in case there is one
     * @param id the id of the activity being removed
     * @param spanData span data that can be updated
     *
     */
    static popActivity(id: number, spanData?: {
        [key: string]: any;
    }): void;
    /**
     * Get span based on activity id
     */
    static getActivitySpan(id: number): Span | undefined;
}
export {};
//# sourceMappingURL=tracing.d.ts.map