import * as tslib_1 from "tslib";
import { Severity } from '@sentry/types';
import { addInstrumentationHandler, getGlobalObject, isMatchingPattern, logger, safeJoin, supportsNativeFetch, timestampWithMs, } from '@sentry/utils';
import { SpanStatus } from '../spanstatus';
var global = getGlobalObject();
var defaultTracingOrigins = ['localhost', /^\//];
/**
 * Tracing Integration
 */
var Tracing = /** @class */ (function () {
    /**
     * Constructor for Tracing
     *
     * @param _options TracingOptions
     */
    function Tracing(_options) {
        /**
         * @inheritDoc
         */
        this.name = Tracing.id;
        this._emitOptionsWarning = false;
        if (global.performance) {
            if (global.performance.mark) {
                global.performance.mark('sentry-tracing-init');
            }
            Tracing._trackLCP();
        }
        var defaults = {
            beforeNavigate: function (location) {
                return location.pathname;
            },
            debug: {
                spanDebugTimingInfo: false,
                writeAsBreadcrumbs: false,
            },
            idleTimeout: 500,
            markBackgroundTransactions: true,
            maxTransactionDuration: 600,
            shouldCreateSpanForRequest: function (url) {
                var origins = (_options && _options.tracingOrigins) || defaultTracingOrigins;
                return (origins.some(function (origin) { return isMatchingPattern(url, origin); }) &&
                    !isMatchingPattern(url, 'sentry_key'));
            },
            startTransactionOnLocationChange: true,
            startTransactionOnPageLoad: true,
            traceFetch: true,
            traceXHR: true,
            tracingOrigins: defaultTracingOrigins,
        };
        // NOTE: Logger doesn't work in contructors, as it's initialized after integrations instances
        if (!_options || !Array.isArray(_options.tracingOrigins) || _options.tracingOrigins.length === 0) {
            this._emitOptionsWarning = true;
        }
        Tracing.options = tslib_1.__assign({}, defaults, _options);
    }
    /**
     * @inheritDoc
     */
    Tracing.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {
        Tracing._getCurrentHub = getCurrentHub;
        if (this._emitOptionsWarning) {
            logger.warn('[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.');
            logger.warn("[Tracing] We added a reasonable default for you: " + defaultTracingOrigins);
        }
        // Starting pageload transaction
        if (global.location && Tracing.options && Tracing.options.startTransactionOnPageLoad) {
            Tracing.startIdleTransaction({
                name: Tracing.options.beforeNavigate(window.location),
                op: 'pageload',
            });
        }
        this._setupXHRTracing();
        this._setupFetchTracing();
        this._setupHistory();
        this._setupErrorHandling();
        this._setupBackgroundTabDetection();
        Tracing._pingHeartbeat();
        // This EventProcessor makes sure that the transaction is not longer than maxTransactionDuration
        addGlobalEventProcessor(function (event) {
            var self = getCurrentHub().getIntegration(Tracing);
            if (!self) {
                return event;
            }
            var isOutdatedTransaction = event.timestamp &&
                event.start_timestamp &&
                (event.timestamp - event.start_timestamp > Tracing.options.maxTransactionDuration ||
                    event.timestamp - event.start_timestamp < 0);
            if (Tracing.options.maxTransactionDuration !== 0 && event.type === 'transaction' && isOutdatedTransaction) {
                Tracing._log("[Tracing] Transaction: " + SpanStatus.Cancelled + " since it maxed out maxTransactionDuration");
                if (event.contexts && event.contexts.trace) {
                    event.contexts.trace = tslib_1.__assign({}, event.contexts.trace, { status: SpanStatus.DeadlineExceeded });
                    event.tags = tslib_1.__assign({}, event.tags, { maxTransactionDurationExceeded: 'true' });
                }
            }
            return event;
        });
    };
    /**
     * Pings the heartbeat
     */
    Tracing._pingHeartbeat = function () {
        Tracing._heartbeatTimer = setTimeout(function () {
            Tracing._beat();
        }, 5000);
    };
    /**
     * Checks when entries of Tracing._activities are not changing for 3 beats. If this occurs we finish the transaction
     *
     */
    Tracing._beat = function () {
        clearTimeout(Tracing._heartbeatTimer);
        var keys = Object.keys(Tracing._activities);
        if (keys.length) {
            var heartbeatString = keys.reduce(function (prev, current) { return prev + current; });
            if (heartbeatString === Tracing._prevHeartbeatString) {
                Tracing._heartbeatCounter++;
            }
            else {
                Tracing._heartbeatCounter = 0;
            }
            if (Tracing._heartbeatCounter >= 3) {
                if (Tracing._activeTransaction) {
                    Tracing._log("[Tracing] Transaction: " + SpanStatus.Cancelled + " -> Heartbeat safeguard kicked in since content hasn't changed for 3 beats");
                    Tracing._activeTransaction.setStatus(SpanStatus.DeadlineExceeded);
                    Tracing._activeTransaction.setTag('heartbeat', 'failed');
                    Tracing.finishIdleTransaction(timestampWithMs());
                }
            }
            Tracing._prevHeartbeatString = heartbeatString;
        }
        Tracing._pingHeartbeat();
    };
    /**
     * Discards active transactions if tab moves to background
     */
    Tracing.prototype._setupBackgroundTabDetection = function () {
        if (Tracing.options && Tracing.options.markBackgroundTransactions && global.document) {
            document.addEventListener('visibilitychange', function () {
                if (document.hidden && Tracing._activeTransaction) {
                    Tracing._log("[Tracing] Transaction: " + SpanStatus.Cancelled + " -> since tab moved to the background");
                    Tracing._activeTransaction.setStatus(SpanStatus.Cancelled);
                    Tracing._activeTransaction.setTag('visibilitychange', 'document.hidden');
                    Tracing.finishIdleTransaction(timestampWithMs());
                }
            });
        }
    };
    /**
     * Unsets the current active transaction + activities
     */
    Tracing._resetActiveTransaction = function () {
        // We want to clean up after ourselves
        // If there is still the active transaction on the scope we remove it
        var _getCurrentHub = Tracing._getCurrentHub;
        if (_getCurrentHub) {
            var hub = _getCurrentHub();
            var scope = hub.getScope();
            if (scope) {
                if (scope.getSpan() === Tracing._activeTransaction) {
                    scope.setSpan(undefined);
                }
            }
        }
        // ------------------------------------------------------------------
        Tracing._activeTransaction = undefined;
        Tracing._activities = {};
    };
    /**
     * Registers to History API to detect navigation changes
     */
    Tracing.prototype._setupHistory = function () {
        if (Tracing.options.startTransactionOnLocationChange) {
            addInstrumentationHandler({
                callback: historyCallback,
                type: 'history',
            });
        }
    };
    /**
     * Attaches to fetch to add sentry-trace header + creating spans
     */
    Tracing.prototype._setupFetchTracing = function () {
        if (Tracing.options.traceFetch && supportsNativeFetch()) {
            addInstrumentationHandler({
                callback: fetchCallback,
                type: 'fetch',
            });
        }
    };
    /**
     * Attaches to XHR to add sentry-trace header + creating spans
     */
    Tracing.prototype._setupXHRTracing = function () {
        if (Tracing.options.traceXHR) {
            addInstrumentationHandler({
                callback: xhrCallback,
                type: 'xhr',
            });
        }
    };
    /**
     * Configures global error listeners
     */
    Tracing.prototype._setupErrorHandling = function () {
        // tslint:disable-next-line: completed-docs
        function errorCallback() {
            if (Tracing._activeTransaction) {
                /**
                 * If an error or unhandled promise occurs, we mark the active transaction as failed
                 */
                Tracing._log("[Tracing] Transaction: " + SpanStatus.InternalError + " -> Global error occured");
                Tracing._activeTransaction.setStatus(SpanStatus.InternalError);
            }
        }
        addInstrumentationHandler({
            callback: errorCallback,
            type: 'error',
        });
        addInstrumentationHandler({
            callback: errorCallback,
            type: 'unhandledrejection',
        });
    };
    /**
     * Uses logger.log to log things in the SDK or as breadcrumbs if defined in options
     */
    Tracing._log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (Tracing.options && Tracing.options.debug && Tracing.options.debug.writeAsBreadcrumbs) {
            var _getCurrentHub = Tracing._getCurrentHub;
            if (_getCurrentHub) {
                _getCurrentHub().addBreadcrumb({
                    category: 'tracing',
                    level: Severity.Debug,
                    message: safeJoin(args, ' '),
                    type: 'debug',
                });
            }
        }
        logger.log.apply(logger, tslib_1.__spread(args));
    };
    /**
     * Starts a Transaction waiting for activity idle to finish
     */
    Tracing.startIdleTransaction = function (transactionContext) {
        Tracing._log('[Tracing] startIdleTransaction');
        var _getCurrentHub = Tracing._getCurrentHub;
        if (!_getCurrentHub) {
            return undefined;
        }
        var hub = _getCurrentHub();
        if (!hub) {
            return undefined;
        }
        Tracing._activeTransaction = hub.startTransaction(tslib_1.__assign({ trimEnd: true }, transactionContext));
        // We set the transaction here on the scope so error events pick up the trace context and attach it to the error
        hub.configureScope(function (scope) { return scope.setSpan(Tracing._activeTransaction); });
        // The reason we do this here is because of cached responses
        // If we start and transaction without an activity it would never finish since there is no activity
        var id = Tracing.pushActivity('idleTransactionStarted');
        setTimeout(function () {
            Tracing.popActivity(id);
        }, (Tracing.options && Tracing.options.idleTimeout) || 100);
        return Tracing._activeTransaction;
    };
    /**
     * Finishes the current active transaction
     */
    Tracing.finishIdleTransaction = function (endTimestamp) {
        var active = Tracing._activeTransaction;
        if (active) {
            Tracing._log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString());
            Tracing._addPerformanceEntries(active);
            if (active.spanRecorder) {
                active.spanRecorder.spans = active.spanRecorder.spans.filter(function (span) {
                    // If we are dealing with the transaction itself, we just return it
                    if (span.spanId === active.spanId) {
                        return span;
                    }
                    // We cancel all pending spans with status "cancelled" to indicate the idle transaction was finished early
                    if (!span.endTimestamp) {
                        span.endTimestamp = endTimestamp;
                        span.setStatus(SpanStatus.Cancelled);
                        Tracing._log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));
                    }
                    // We remove all spans that happend after the end of the transaction
                    // This is here to prevent super long transactions and timing issues
                    var keepSpan = span.startTimestamp < endTimestamp;
                    if (!keepSpan) {
                        Tracing._log('[Tracing] discarding Span since it happened after Transaction was finished', JSON.stringify(span, undefined, 2));
                    }
                    return keepSpan;
                });
            }
            Tracing._log('[Tracing] flushing IdleTransaction');
            active.finish();
            Tracing._resetActiveTransaction();
        }
        else {
            Tracing._log('[Tracing] No active IdleTransaction');
        }
    };
    /**
     * This uses `performance.getEntries()` to add additional spans to the active transaction.
     * Also, we update our timings since we consider the timings in this API to be more correct than our manual
     * measurements.
     *
     * @param transactionSpan The transaction span
     */
    Tracing._addPerformanceEntries = function (transactionSpan) {
        if (!global.performance) {
            // Gatekeeper if performance API not available
            return;
        }
        Tracing._log('[Tracing] Adding & adjusting spans using Performance API');
        // FIXME: depending on the 'op' directly is brittle.
        if (transactionSpan.op === 'pageload') {
            // Force any pending records to be dispatched.
            Tracing._forceLCP();
            if (Tracing._lcp) {
                // Set the last observed LCP score.
                transactionSpan.setData('_sentry_web_vitals', { LCP: Tracing._lcp });
            }
        }
        var timeOrigin = Tracing._msToSec(performance.timeOrigin);
        // tslint:disable-next-line: completed-docs
        function addPerformanceNavigationTiming(parent, entry, event) {
            parent.startChild({
                description: event,
                endTimestamp: timeOrigin + Tracing._msToSec(entry[event + "End"]),
                op: 'browser',
                startTimestamp: timeOrigin + Tracing._msToSec(entry[event + "Start"]),
            });
        }
        // tslint:disable-next-line: completed-docs
        function addRequest(parent, entry) {
            parent.startChild({
                description: 'request',
                endTimestamp: timeOrigin + Tracing._msToSec(entry.responseEnd),
                op: 'browser',
                startTimestamp: timeOrigin + Tracing._msToSec(entry.requestStart),
            });
            parent.startChild({
                description: 'response',
                endTimestamp: timeOrigin + Tracing._msToSec(entry.responseEnd),
                op: 'browser',
                startTimestamp: timeOrigin + Tracing._msToSec(entry.responseStart),
            });
        }
        var entryScriptSrc;
        if (global.document) {
            // tslint:disable-next-line: prefer-for-of
            for (var i = 0; i < document.scripts.length; i++) {
                // We go through all scripts on the page and look for 'data-entry'
                // We remember the name and measure the time between this script finished loading and
                // our mark 'sentry-tracing-init'
                if (document.scripts[i].dataset.entry === 'true') {
                    entryScriptSrc = document.scripts[i].src;
                    break;
                }
            }
        }
        var entryScriptStartEndTime;
        var tracingInitMarkStartTime;
        // tslint:disable: no-unsafe-any
        performance
            .getEntries()
            .slice(Tracing._performanceCursor)
            .forEach(function (entry) {
            var startTime = Tracing._msToSec(entry.startTime);
            var duration = Tracing._msToSec(entry.duration);
            if (transactionSpan.op === 'navigation' && timeOrigin + startTime < transactionSpan.startTimestamp) {
                return;
            }
            switch (entry.entryType) {
                case 'navigation':
                    addPerformanceNavigationTiming(transactionSpan, entry, 'unloadEvent');
                    addPerformanceNavigationTiming(transactionSpan, entry, 'domContentLoadedEvent');
                    addPerformanceNavigationTiming(transactionSpan, entry, 'loadEvent');
                    addPerformanceNavigationTiming(transactionSpan, entry, 'connect');
                    addPerformanceNavigationTiming(transactionSpan, entry, 'domainLookup');
                    addRequest(transactionSpan, entry);
                    break;
                case 'mark':
                case 'paint':
                case 'measure':
                    var mark = transactionSpan.startChild({
                        description: entry.name,
                        op: entry.entryType,
                    });
                    mark.startTimestamp = timeOrigin + startTime;
                    mark.endTimestamp = mark.startTimestamp + duration;
                    if (tracingInitMarkStartTime === undefined && entry.name === 'sentry-tracing-init') {
                        tracingInitMarkStartTime = mark.startTimestamp;
                    }
                    break;
                case 'resource':
                    var resourceName_1 = entry.name.replace(window.location.origin, '');
                    if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {
                        // We need to update existing spans with new timing info
                        if (transactionSpan.spanRecorder) {
                            transactionSpan.spanRecorder.spans.map(function (finishedSpan) {
                                if (finishedSpan.description && finishedSpan.description.indexOf(resourceName_1) !== -1) {
                                    finishedSpan.startTimestamp = timeOrigin + startTime;
                                    finishedSpan.endTimestamp = finishedSpan.startTimestamp + duration;
                                }
                            });
                        }
                    }
                    else {
                        var resource = transactionSpan.startChild({
                            description: entry.initiatorType + " " + resourceName_1,
                            op: "resource",
                        });
                        resource.startTimestamp = timeOrigin + startTime;
                        resource.endTimestamp = resource.startTimestamp + duration;
                        // We remember the entry script end time to calculate the difference to the first init mark
                        if (entryScriptStartEndTime === undefined && (entryScriptSrc || '').indexOf(resourceName_1) > -1) {
                            entryScriptStartEndTime = resource.endTimestamp;
                        }
                    }
                    break;
                default:
                // Ignore other entry types.
            }
        });
        if (entryScriptStartEndTime !== undefined && tracingInitMarkStartTime !== undefined) {
            transactionSpan.startChild({
                description: 'evaluation',
                endTimestamp: tracingInitMarkStartTime,
                op: "script",
                startTimestamp: entryScriptStartEndTime,
            });
        }
        Tracing._performanceCursor = Math.max(performance.getEntries().length - 1, 0);
        // tslint:enable: no-unsafe-any
    };
    /**
     * Starts tracking the Largest Contentful Paint on the current page.
     */
    Tracing._trackLCP = function () {
        // Based on reference implementation from https://web.dev/lcp/#measure-lcp-in-javascript.
        // Use a try/catch instead of feature detecting `largest-contentful-paint`
        // support, since some browsers throw when using the new `type` option.
        // https://bugs.webkit.org/show_bug.cgi?id=209216
        try {
            // Keep track of whether (and when) the page was first hidden, see:
            // https://github.com/w3c/page-visibility/issues/29
            // NOTE: ideally this check would be performed in the document <head>
            // to avoid cases where the visibility state changes before this code runs.
            var firstHiddenTime_1 = document.visibilityState === 'hidden' ? 0 : Infinity;
            document.addEventListener('visibilitychange', function (event) {
                firstHiddenTime_1 = Math.min(firstHiddenTime_1, event.timeStamp);
            }, { once: true });
            var updateLCP_1 = function (entry) {
                // Only include an LCP entry if the page wasn't hidden prior to
                // the entry being dispatched. This typically happens when a page is
                // loaded in a background tab.
                if (entry.startTime < firstHiddenTime_1) {
                    // NOTE: the `startTime` value is a getter that returns the entry's
                    // `renderTime` value, if available, or its `loadTime` value otherwise.
                    // The `renderTime` value may not be available if the element is an image
                    // that's loaded cross-origin without the `Timing-Allow-Origin` header.
                    Tracing._lcp = tslib_1.__assign({}, (entry.id && { elementId: entry.id }), (entry.size && { elementSize: entry.size }), { value: entry.startTime });
                }
            };
            // Create a PerformanceObserver that calls `updateLCP` for each entry.
            var po_1 = new PerformanceObserver(function (entryList) {
                entryList.getEntries().forEach(updateLCP_1);
            });
            // Observe entries of type `largest-contentful-paint`, including buffered entries,
            // i.e. entries that occurred before calling `observe()` below.
            po_1.observe({
                buffered: true,
                // @ts-ignore
                type: 'largest-contentful-paint',
            });
            Tracing._forceLCP = function () {
                po_1.takeRecords().forEach(updateLCP_1);
            };
        }
        catch (e) {
            // Do nothing if the browser doesn't support this API.
        }
    };
    /**
     * Sets the status of the current active transaction (if there is one)
     */
    Tracing.setTransactionStatus = function (status) {
        var active = Tracing._activeTransaction;
        if (active) {
            Tracing._log('[Tracing] setTransactionStatus', status);
            active.setStatus(status);
        }
    };
    /**
     * Returns the current active idle transaction if there is one
     */
    Tracing.getTransaction = function () {
        return Tracing._activeTransaction;
    };
    /**
     * Converts from milliseconds to seconds
     * @param time time in ms
     */
    Tracing._msToSec = function (time) {
        return time / 1000;
    };
    /**
     * Adds debug data to the span
     */
    Tracing._addSpanDebugInfo = function (span) {
        // tslint:disable: no-unsafe-any
        var debugData = {};
        if (global.performance) {
            debugData.performance = true;
            debugData['performance.timeOrigin'] = global.performance.timeOrigin;
            debugData['performance.now'] = global.performance.now();
            // tslint:disable-next-line: deprecation
            if (global.performance.timing) {
                // tslint:disable-next-line: deprecation
                debugData['performance.timing.navigationStart'] = performance.timing.navigationStart;
            }
        }
        else {
            debugData.performance = false;
        }
        debugData['Date.now()'] = Date.now();
        span.setData('sentry_debug', debugData);
        // tslint:enable: no-unsafe-any
    };
    /**
     * Starts tracking for a specifc activity
     *
     * @param name Name of the activity, can be any string (Only used internally to identify the activity)
     * @param spanContext If provided a Span with the SpanContext will be created.
     * @param options _autoPopAfter_ | Time in ms, if provided the activity will be popped automatically after this timeout. This can be helpful in cases where you cannot gurantee your application knows the state and calls `popActivity` for sure.
     */
    Tracing.pushActivity = function (name, spanContext, options) {
        var activeTransaction = Tracing._activeTransaction;
        if (!activeTransaction) {
            Tracing._log("[Tracing] Not pushing activity " + name + " since there is no active transaction");
            return 0;
        }
        var _getCurrentHub = Tracing._getCurrentHub;
        if (spanContext && _getCurrentHub) {
            var hub = _getCurrentHub();
            if (hub) {
                var span = activeTransaction.startChild(spanContext);
                Tracing._activities[Tracing._currentIndex] = {
                    name: name,
                    span: span,
                };
            }
        }
        else {
            Tracing._activities[Tracing._currentIndex] = {
                name: name,
            };
        }
        Tracing._log("[Tracing] pushActivity: " + name + "#" + Tracing._currentIndex);
        Tracing._log('[Tracing] activies count', Object.keys(Tracing._activities).length);
        if (options && typeof options.autoPopAfter === 'number') {
            Tracing._log("[Tracing] auto pop of: " + name + "#" + Tracing._currentIndex + " in " + options.autoPopAfter + "ms");
            var index_1 = Tracing._currentIndex;
            setTimeout(function () {
                Tracing.popActivity(index_1, {
                    autoPop: true,
                    status: SpanStatus.DeadlineExceeded,
                });
            }, options.autoPopAfter);
        }
        return Tracing._currentIndex++;
    };
    /**
     * Removes activity and finishes the span in case there is one
     * @param id the id of the activity being removed
     * @param spanData span data that can be updated
     *
     */
    Tracing.popActivity = function (id, spanData) {
        // The !id is on purpose to also fail with 0
        // Since 0 is returned by push activity in case there is no active transaction
        if (!id) {
            return;
        }
        var activity = Tracing._activities[id];
        if (activity) {
            Tracing._log("[Tracing] popActivity " + activity.name + "#" + id);
            var span_1 = activity.span;
            if (span_1) {
                if (spanData) {
                    Object.keys(spanData).forEach(function (key) {
                        span_1.setData(key, spanData[key]);
                        if (key === 'status_code') {
                            span_1.setHttpStatus(spanData[key]);
                        }
                        if (key === 'status') {
                            span_1.setStatus(spanData[key]);
                        }
                    });
                }
                if (Tracing.options && Tracing.options.debug && Tracing.options.debug.spanDebugTimingInfo) {
                    Tracing._addSpanDebugInfo(span_1);
                }
                span_1.finish();
            }
            // tslint:disable-next-line: no-dynamic-delete
            delete Tracing._activities[id];
        }
        var count = Object.keys(Tracing._activities).length;
        Tracing._log('[Tracing] activies count', count);
        if (count === 0 && Tracing._activeTransaction) {
            var timeout = Tracing.options && Tracing.options.idleTimeout;
            Tracing._log("[Tracing] Flushing Transaction in " + timeout + "ms");
            // We need to add the timeout here to have the real endtimestamp of the transaction
            // Remeber timestampWithMs is in seconds, timeout is in ms
            var end_1 = timestampWithMs() + timeout / 1000;
            setTimeout(function () {
                Tracing.finishIdleTransaction(end_1);
            }, timeout);
        }
    };
    /**
     * Get span based on activity id
     */
    Tracing.getActivitySpan = function (id) {
        if (!id) {
            return undefined;
        }
        var activity = Tracing._activities[id];
        if (activity) {
            return activity.span;
        }
        return undefined;
    };
    /**
     * @inheritDoc
     */
    Tracing.id = 'Tracing';
    Tracing._currentIndex = 1;
    Tracing._activities = {};
    Tracing._performanceCursor = 0;
    Tracing._heartbeatTimer = 0;
    Tracing._heartbeatCounter = 0;
    /** Force any pending LargestContentfulPaint records to be dispatched. */
    Tracing._forceLCP = function () {
        /* No-op, replaced later if LCP API is available. */
    };
    return Tracing;
}());
export { Tracing };
/**
 * Creates breadcrumbs from XHR API calls
 */
function xhrCallback(handlerData) {
    if (!Tracing.options.traceXHR) {
        return;
    }
    // tslint:disable-next-line: no-unsafe-any
    if (!handlerData || !handlerData.xhr || !handlerData.xhr.__sentry_xhr__) {
        return;
    }
    // tslint:disable: no-unsafe-any
    var xhr = handlerData.xhr.__sentry_xhr__;
    if (!Tracing.options.shouldCreateSpanForRequest(xhr.url)) {
        return;
    }
    // We only capture complete, non-sentry requests
    if (handlerData.xhr.__sentry_own_request__) {
        return;
    }
    if (handlerData.endTimestamp && handlerData.xhr.__sentry_xhr_activity_id__) {
        Tracing.popActivity(handlerData.xhr.__sentry_xhr_activity_id__, handlerData.xhr.__sentry_xhr__);
        return;
    }
    handlerData.xhr.__sentry_xhr_activity_id__ = Tracing.pushActivity('xhr', {
        data: tslib_1.__assign({}, xhr.data, { type: 'xhr' }),
        description: xhr.method + " " + xhr.url,
        op: 'http',
    });
    // Adding the trace header to the span
    var activity = Tracing._activities[handlerData.xhr.__sentry_xhr_activity_id__];
    if (activity) {
        var span = activity.span;
        if (span && handlerData.xhr.setRequestHeader) {
            try {
                handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());
            }
            catch (_) {
                // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.
            }
        }
    }
    // tslint:enable: no-unsafe-any
}
/**
 * Creates breadcrumbs from fetch API calls
 */
function fetchCallback(handlerData) {
    // tslint:disable: no-unsafe-any
    if (!Tracing.options.traceFetch) {
        return;
    }
    if (!Tracing.options.shouldCreateSpanForRequest(handlerData.fetchData.url)) {
        return;
    }
    if (handlerData.endTimestamp && handlerData.fetchData.__activity) {
        Tracing.popActivity(handlerData.fetchData.__activity, handlerData.fetchData);
    }
    else {
        handlerData.fetchData.__activity = Tracing.pushActivity('fetch', {
            data: tslib_1.__assign({}, handlerData.fetchData, { type: 'fetch' }),
            description: handlerData.fetchData.method + " " + handlerData.fetchData.url,
            op: 'http',
        });
        var activity = Tracing._activities[handlerData.fetchData.__activity];
        if (activity) {
            var span = activity.span;
            if (span) {
                var options = (handlerData.args[1] = handlerData.args[1] || {});
                if (options.headers) {
                    if (Array.isArray(options.headers)) {
                        options.headers = tslib_1.__spread(options.headers, [{ 'sentry-trace': span.toTraceparent() }]);
                    }
                    else {
                        options.headers = tslib_1.__assign({}, options.headers, { 'sentry-trace': span.toTraceparent() });
                    }
                }
                else {
                    options.headers = { 'sentry-trace': span.toTraceparent() };
                }
            }
        }
    }
    // tslint:enable: no-unsafe-any
}
/**
 * Creates transaction from navigation changes
 */
function historyCallback(_) {
    if (Tracing.options.startTransactionOnLocationChange && global && global.location) {
        Tracing.finishIdleTransaction(timestampWithMs());
        Tracing.startIdleTransaction({
            name: Tracing.options.beforeNavigate(window.location),
            op: 'navigation',
        });
    }
}
//# sourceMappingURL=tracing.js.map